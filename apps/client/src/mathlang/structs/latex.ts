import { StringNumType, tree } from "./stringfn.js";

export type TexEntry = { bp: number; latex: string };
export type TeXDef = {
  [key: string]: (latex: string, bp?: number) => TexEntry;
};
export const tex: TeXDef = {
  symbol: (latex, bp = 50) => ({
    bp,
    latex: `\\${latex}`,
  }),
  text: (latex, bp = 50) => ({
    bp,
    latex: `\\text{${latex}}`,
  }),
  manual: (latex, bp = 50) => ({
    bp,
    latex,
  }),
};
export const functions: { [key: string]: TexEntry } = {
  arcsin: tex.symbol("arcsin"),
  cosec: tex.symbol("cosec"),
  deg: tex.symbol("deg"),
  sec: tex.symbol("sec"),
  arccos: tex.symbol("arccos"),
  acos: tex.text("acos"),
  acosh: tex.text("acosh"),
  asin: tex.text("asin"),
  asinh: tex.text("asinh"),
  atan: tex.text("atan"),
  atanh: tex.text("atanh"),
  atan2: tex.text("atan^2"),
  cosh: tex.symbol("cosh"),
  clz32: tex.text("clz32"),
  dim: tex.symbol("dim"),
  sin: tex.symbol("sin"),
  arctan: tex.symbol("arctan"),
  cot: tex.symbol("cot"),
  exp: tex.symbol("exp"),
  sinh: tex.symbol("sinh"),
  sh: tex.symbol("sh"),
  arcctg: tex.symbol("arcctg"),
  coth: tex.symbol("coth"),
  ker: tex.symbol("ker"),
  tan: tex.symbol("tan"),
  arg: tex.symbol("arg"),
  csc: tex.symbol("csc"),
  lg: tex.symbol("lg"),
  tanh: tex.symbol("tanh"),
  ch: tex.symbol("ch"),
  ctg: tex.symbol("ctg"),
  ln: tex.symbol("ln"),
  tg: tex.symbol("tg"),
  cos: tex.symbol("cos"),
  cth: tex.symbol("cth"),
  log: tex.symbol("log"),
  th: tex.symbol("th"),
  argmax: tex.symbol("argmax"),
  injlim: tex.symbol("injlim"),
  min: tex.symbol("min"),
  varinjlim: tex.symbol("varinjlim"),
  argmin: tex.symbol("argmin"),
  lim: tex.symbol("lim"),
  plim: tex.symbol("plim"),
  varliminf: tex.symbol("varliminf"),
  det: tex.symbol("det"),
  liminf: tex.symbol("liminf"),
  Pr: tex.symbol("Pr"),
  varlimsup: tex.symbol("varlimsup"),
  gcd: tex.symbol("gcd"),
  limsup: tex.symbol("limsup"),
  projlim: tex.symbol("projlim"),
  varprojli: tex.symbol("varprojli"),
  inf: tex.symbol("inf"),
  max: tex.symbol("max"),
  sup: tex.symbol("sup"),
  sqrt: tex.symbol("sqrt"),
  hypot: tex.text("hypot"),
};

export const symbols: { [key: string]: TexEntry } = {
  Alpha: tex.symbol("Alpha"),
  Beta: tex.symbol("Beta"),
  Gamma: tex.symbol("Gamma"),
  Delta: tex.symbol("Delta"),
  Epsilon: tex.symbol("Epsilon"),
  Zeta: tex.symbol("Zeta"),
  Eta: tex.symbol("Eta"),
  Theta: tex.symbol("Theta"),
  Iota: tex.symbol("Iota"),
  Kappa: tex.symbol("Kappa"),
  Lambda: tex.symbol("Lambda"),
  Mu: tex.symbol("Mu"),
  Nu: tex.symbol("Nu"),
  Xi: tex.symbol("Xi"),
  Omicron: tex.symbol("Omicron"),
  Pi: tex.symbol("Pi"),
  Rho: tex.symbol("Rho"),
  Sigma: tex.symbol("Sigma"),
  Tau: tex.symbol("Tau"),
  Upsilon: tex.symbol("Upsilon"),
  Phi: tex.symbol("Phi"),
  Chi: tex.symbol("Chi"),
  Psi: tex.symbol("Psi"),
  Omega: tex.symbol("Omega"),
  varGamma: tex.symbol("varGamma"),
  varDelta: tex.symbol("varDelta"),
  varTheta: tex.symbol("varTheta"),
  varLambda: tex.symbol("varLambda"),
  varXi: tex.symbol("varXi"),
  varPi: tex.symbol("varPi"),
  varSigma: tex.symbol("varSigma"),
  varUpsilon: tex.symbol("varUpsilon"),
  varPhi: tex.symbol("varPhi"),
  varPsi: tex.symbol("varPsi"),
  varOmega: tex.symbol("varOmega"),
  alpha: tex.symbol("alpha"),
  beta: tex.symbol("beta"),
  gamma: tex.symbol("gamma"),
  delta: tex.symbol("delta"),
  epsilon: tex.symbol("epsilon"),
  zeta: tex.symbol("zeta"),
  eta: tex.symbol("eta"),
  theta: tex.symbol("theta"),
  iota: tex.symbol("iota"),
  kappa: tex.symbol("kappa"),
  lambda: tex.symbol("lambda"),
  mu: tex.symbol("mu"),
  nu: tex.symbol("nu"),
  xi: tex.symbol("xi"),
  omicron: tex.symbol("omicron"),
  pi: tex.symbol("pi"),
  rho: tex.symbol("rho"),
  sigma: tex.symbol("sigma"),
  tau: tex.symbol("tau"),
  upsilon: tex.symbol("upsilon"),
  phi: tex.symbol("phi"),
  chi: tex.symbol("chi"),
  psi: tex.symbol("psi"),
  omega: tex.symbol("omega"),
  varepsilon: tex.symbol("varepsilon"),
  varkappa: tex.symbol("varkappa"),
  vartheta: tex.symbol("vartheta"),
  thetasym: tex.symbol("thetasym"),
  varpi: tex.symbol("varpi"),
  varrho: tex.symbol("varrho"),
  varsigma: tex.symbol("varsigma"),
  varphi: tex.symbol("varphi"),
  digamma: tex.symbol("digamma"),
  imath: tex.symbol("imath"),
  nabla: tex.symbol("nabla"),
  Im: tex.symbol("Im"),
  Reals: tex.symbol("Reals"),
  jmath: tex.symbol("jmath"),
  partial: tex.symbol("partial"),
  image: tex.symbol("image"),
  wp: tex.symbol("wp"),
  aleph: tex.symbol("aleph"),
  Game: tex.symbol("Game"),
  Bbbk: tex.symbol("Bbbk"),
  weierp: tex.symbol("weierp"),
  alef: tex.symbol("alef"),
  Finv: tex.symbol("Finv"),
  N: tex.symbol("N"),
  Z: tex.symbol("Z"),
  alefsym: tex.symbol("alefsym"),
  cnums: tex.symbol("cnums"),
  natnums: tex.symbol("natnums"),
  beth: tex.symbol("beth"),
  Complex: tex.symbol("Complex"),
  R: tex.symbol("R"),
  gimel: tex.symbol("gimel"),
  ell: tex.symbol("ell"),
  Re: tex.symbol("Re"),
  daleth: tex.symbol("daleth"),
  hbar: tex.symbol("hbar"),
  real: tex.symbol("real"),
  eth: tex.symbol("eth"),
  hslash: tex.symbol("hslash"),
  reals: tex.symbol("reals"),
};
export const delimiters = [
  { pattern: /^\(/, bp: 1 },
  { pattern: /^\)/, bp: 1 },
  { pattern: /^\{/, bp: 1 },
  { pattern: /^\}/, bp: 1 },
  { pattern: /^\[/, bp: 1 },
  { pattern: /^\]/, bp: 1 },
  { pattern: /^,/, bp: 1 },
  { pattern: /^;/, bp: 1 },
  { pattern: /^'/, bp: 1 },
];
export const operators = [
  { pattern: /^==/, bp: 5, kind: "binop" },
  { pattern: /^=/, bp: 5, kind: "binop" },
  { pattern: /^[><]=?/, bp: 5, kind: "binop" },
  { pattern: /^\+/, bp: 10, kind: "binop" },
  { pattern: /^-/, bp: 11, kind: "binop" },
  { pattern: /^\*/, bp: 12, kind: "binop" },
  { pattern: /^[\/]/, bp: 13, kind: "binop" },
  { pattern: /^%/, bp: 14, kind: "binop" },
  { pattern: /^[\/\/]/, bp: 15, kind: "binop" },
  { pattern: /^\^/, bp: 16, kind: "binop" },
  { pattern: /^@/, bp: 17, kind: "binop" },
  { pattern: /^!/, bp: 18, kind: "unop" },
];

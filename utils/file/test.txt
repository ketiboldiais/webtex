testing

    const lhs = N.digits.join('');
    const rhs = this.value.join('');
    const createZeros = (n: number): number[] => new Array(n).fill(0);
    const last = (array: any[]) => array[array.length - 1];
    const addCarry = (carry: number, digits: number[]) => {
      if (carry === 0) return;
      let value = last(digits) + carry;
      if (value > 10) {
        digits[digits.length - 1] = 0;
        digits.unshift(value % 10);
      } else {
        digits[digits.length - 1] = value;
      }
    };
    const answer: any[] = [];
    const entries: number[][] = [];
    let carry = 0;
    for (let lcur = 0; lcur < lhs.length; lcur++) {
      const leftDigit = lhs[lhs.length - 1 - lcur];
      const multiplications = createZeros(lcur);
      for (let rcur = 0; rcur < rhs.length; rcur++) {
        const rightDigit = rhs[rhs.length - 1 - rcur];
        const times = Number(leftDigit) * Number(rightDigit) + carry;
        const ones = times % 10;
        carry = Math.floor(times / 10);
        multiplications.unshift(ones);
      }
      if (carry !== 0) {
        multiplications.unshift(carry);
        carry = 0;
      }
      entries.push(multiplications);
    }
    addCarry(carry, last(entries));
    const maxLength = entries
      .map((entry) => entry.length)
      .reduce((acc, entry) => Math.max(acc, entry), 0);
    entries.forEach((entry) => entry.reverse());
    carry = 0;
    for (let idx = 0; idx < maxLength; ++idx) {
      const sum = entries
        .map((entry) => entry[idx] || 0)
        .reduce((acc, value) => acc + value, carry);
      const ones = sum % 10;
      carry = Math.floor(sum / 10);
      answer.unshift(ones);
    }
    addCarry(carry, answer);
    


    
const num = {
  integer: (a: number | string) => new Integer(Number(a)),
  inf: (n: number | string) => new Inf(),
  natural: (n: number | string) => new Natural(Number(n)),
  bigN: (digits: number | string) => {
    return typeof digits === 'number'
      ? new BigN(`${digits}`)
      : new BigN(digits);
  },
  rational: (x: number | string) => {
    if (typeof x === 'string') x = Number(x);
    let n = 0;
    let d = 0;
    if (x === 0) {
      return new Rational([n, d]);
    }
    const a = Math.abs(x);
    n = 0;
    d = 1;
    let r: number;
    while (true) {
      r = n / d;
      if (Math.abs((r - a) / a) < 0.00001) break;
      if (r < a) n++;
      else d++;
    }
    n = x < 0 ? -n : n;
    d = d;
    return new Rational([n, d]);
  },
  real: (r: number | string) => new Real(Number(r)),
  scientific: (x: number) => {
    const s = x.toString().length;
    const res = x.toExponential(s < 20 ? s : 10).split(/e\+?/);
    return new Scientific([Number(res[0]), Number(res[1])]);
  },
};

type NumBuilder = keyof typeof num;

  // § - evalStringBinop
  private evalStringBinop<A extends Node, B extends Node>(
    N: StringBinop<A, B>
  ): Node {
    let left: StringVal = this.evaluate(N.left);
    let right: StringVal = this.evaluate(N.right);
    if (typeof left.value !== 'string' || typeof right.value !== 'string') {
      return this.panic(
        `String operators are only valid on string operands.`
      ) as Node;
    }
    switch (N.op) {
      case '++':
        return node.string(left.value.concat(right.value)) as Node;
      case '--':
        return node.string(right.value.concat(left.value)) as Node;
      default:
        this.panic('Unrecognized string operator.') as Node;
        return node.string('');
    }
  }

  // § - evalMathBinop
  /**
   * Evaluates a math binary expression.
   */
  private evalMathBinop<A extends Node, B extends Node>(
    argNode: MathBinop<A, B>
  ): Node {
    let L = this.evaluate<A, B, Node>(argNode.left);
    let R = this.evaluate<A, B, Node>(argNode.right);
    if (node.is.numeric(L) && node.is.numeric(R)) {
      switch (argNode.op) {
        case '*':
        // return L.multiply(R);
        case '+':
        // return L.add(R);
        case '-':
        // return L.subtract(R);
        case '/':
        // return L.divide(R);
        case '^':
        // return L.power(R);
        case '%':
        // return L.quot(R);
        case 'mod':
        // return L.mod(R);
        case 'rem':
        // return L.rem(R);
        default:
          this.panic('Unrecognized binary math operator.');
          return new Inf();
      }
    }
    this.panic(`Math operators only valid on numerics.`);
    return this.runtimeError as Node;
  }

  private evalId(node: Id) {
    const x = this.env.read(node.value);
    if (x instanceof Rot) {
      this.runtimeError = x;
    }
    return x;
  }
  private evalBind<T extends Node>(node: Bind<T>): T {
    if (!this.env.has(node.name)) {
      this.panic(`Variable ${node.name} hasn’t been declared.`);
    }
    const val = this.evaluate(node.getVal());
    return this.env.assign(node.name, val) as unknown as T;
  }

  private evalDeclare<T extends Node>(node: Binding<T>): T {
    const val = this.evaluate(node.getVal());
    return this.env.declare(node.name, val, node.isConst) as unknown as T;
  }

  private evalAlgebra(node: AlgebraicExpression) {
    return node.read();
  }



  // § - evaluate
  private evaluate<A extends Node, B extends Node, C extends Node = Node>(
    node: Node
  ): C {
    switch (node.kind) {
      case 'algebraic-expression':
        return this.evalAlgebra(node as AlgebraicExpression) as unknown as C;
      case 'identifier':
        return this.evalId(node);
      case 'var-declaration-expression':
      case 'const-declaration-expression':
        return this.evalDeclare(node as Binding<C>);
      case 'assignment-expression':
        return this.evalBind(node as Bind<C>);
      case 'string-binary-expression':
        return this.evalStringBinop(node as StringBinop<A, B>) as unknown as C;
      case 'math-binary-expression':
        return this.evalMathBinop(node as MathBinop<A, B>) as unknown as C;
      case 'inf':
        return node as unknown as C;
      case 'rational':
        return node as unknown as C;
      case 'string':
        return node as unknown as C;
      case 'boolean':
        return node as unknown as C;
      case 'natural':
        return node as unknown as C;
      case 'integer':
        return node as unknown as C;
      case 'real':
        return node as unknown as C;
      case 'scientific':
        return node as unknown as C;
      case 'null':
        return node as unknown as C;
      default:
        this.croak(`Unrecognized node type: ${node.kind}`);
        return this.compileError as C;
    }
  }

  // § - print
  print() {
    display(this.prog);
    return this;
  }
  json() {
    JSON.stringify(this.prog);
  }
  jsonLog() {
    console.log(this.json());
  }
  log() {
    console.log(this.prog);
  }

  // § - interpret
  interpret(): Rot | null | Node {
    if (this.prog === null || this.prog instanceof Rot)
      return this.compileError;
    let result: any = null;
    for (let i = 0; i < this.prog.value.length; i++) {
      if (this.runtimeError) return this.runtimeError;
      result = this.evaluate(this.prog.value[i]);
    }
    return result;
  }
  

  
export class Inf extends Node {
  value: number;
  type: 'inf';
  constructor() {
    super(Infinity, 'inf');
    this.value = Infinity;
    this.type = 'inf';
  }
}

export class Rational extends Node {
  value: [number, number];
  type: NumberType;
  constructor(value: [number, number]) {
    super(value, 'rational');
    this.value = value;
    this.type = 'rational';
  }
}

export class Integer extends Node {
  value: number;
  type: NumberType;
  constructor(value: number) {
    super(value, 'integer');
    this.value = value | 0;
    this.type = 'integer';
  }
}

export class Real extends Node {
  value: number;
  type: NumberType;
  constructor(value: number) {
    super(value, 'real');
    this.value = value;
    this.type = 'real';
  }
}

export class Natural extends Node {
  value: number;
  type: NumberType;
  constructor(value: number) {
    super(value, 'natural');
    this.value = value;
    this.type = 'natural';
  }
}

export class Scientific extends Node {
  value: [number, number];
  type: NumberType;
  constructor(value: [number, number]) {
    super(value, 'scientific');
    this.value = value;
    this.type = 'scientific';
  }
}

export class BigN extends Node {
  value: string;
  type: NumberType;
  private isFloat: boolean;
  constructor(value: string, isFloat: boolean = false) {
    super(value, 'bigN');
    this.value = value;
    this.type = 'bigN';
    this.isFloat = isFloat;
  }
}

const typeLookup: TypeTable = {
  natural: {
    natural: 'natural',
    integer: 'integer',
    scientific: 'scientific',
    rational: 'rational',
    bigN: 'bigN',
    real: 'real',
    inf: 'inf',
    ninf: 'inf',
  },
  integer: {
    natural: 'integer',
    integer: 'integer',
    scientific: 'scientific',
    rational: 'rational',
    bigN: 'bigN',
    real: 'real',
    inf: 'inf',
    ninf: 'ninf',
  },
  scientific: {
    natural: 'scientific',
    integer: 'scientific',
    scientific: 'scientific',
    rational: 'scientific',
    bigN: 'bigN',
    real: 'scientific',
    inf: 'inf',
    ninf: 'ninf',
  },
  rational: {
    natural: 'rational',
    integer: 'rational',
    scientific: 'scientific',
    rational: 'rational',
    bigN: 'bigN',
    real: 'rational',
    inf: 'inf',
    ninf: 'ninf',
  },
  bigN: {
    natural: 'bigN',
    integer: 'bigN',
    scientific: 'bigN',
    rational: 'bigN',
    bigN: 'bigN',
    real: 'bigN',
    inf: 'inf',
    ninf: 'ninf',
  },
  real: {
    natural: 'real',
    integer: 'real',
    scientific: 'scientific',
    rational: 'real',
    bigN: 'bigN',
    real: 'real',
    inf: 'inf',
    ninf: 'ninf',
  },
  inf: {
    natural: 'inf',
    integer: 'inf',
    scientific: 'inf',
    rational: 'inf',
    bigN: 'inf',
    real: 'inf',
    inf: 'inf',
    ninf: 'inf',
  },
  ninf: {
    natural: 'ninf',
    integer: 'ninf',
    scientific: 'ninf',
    rational: 'ninf',
    bigN: 'ninf',
    real: 'ninf',
    inf: 'ninf',
    ninf: 'ninf',
  },
};

import { NumberType } from '../types';

type Value = [string, string] | [number, number] | number | string | bigint;

type N<V extends Value> = V extends [string, string] | bigint | string
  ? 'bigN'
  : V extends [number, number]
  ? 'rational' | 'scientific'
  : NumberType;

type ValueBox<V extends Value> = { value: V };
type TypeBox<T extends NumberType> = { type: T };
type TypeBoxMaker = <T extends NumberType>(type: T) => TypeBox<T>;
type LexBox = { lexeme: string };
type ValTypeBox<V extends Value, T extends NumberType> = ValueBox<V> &
  TypeBox<T>;
type ValTypeMaker = <V extends Value, T extends N<V>>(
  value: V,
  type: T
) => ValTypeBox<V, T>;
type ValBoxMaker = <V extends Value>(value: V) => ValueBox<V>;
type DataBox<V extends Value, T extends NumberType> = ValueBox<V> &
  TypeBox<T> &
  LexBox;
type DataMaker = <V extends Value, T extends N<V>>(
  value: V,
  type: T,
  lexeme: string
) => DataBox<V, T>;
type DataTransformer = <
  V1 extends Value,
  T1 extends NumberType,
  V2 extends Value,
  T2 extends NumberType
>(
  d1: DataBox<V1, T1>,
  d2: DataBox<V2, T2>
) => DataBox<V2, T2>;

const makeVal: ValBoxMaker = (value) => ({ value });
const makeType: TypeBoxMaker = (type) => ({ type });
const makeValType: ValTypeMaker = (value, type) => ({
  value,
  type,
});
const makeLexeme = (lexeme: string): LexBox => ({ lexeme });
const makeData: DataMaker = (value, type, lexeme) => ({
  value,
  type,
  lexeme,
});
const updateData: DataTransformer = (d1, d2) => ({ ...d1, ...d2 });

type Dep = { [name: string]: Fn };
class Fn {
  name: string;
  fn: Function;
  deps: Dep;
  constructor(name: string, fn: Function, deps: Dep = {}) {
    this.name = name;
    this.fn = fn;
    this.deps = {
      intPlus: new Fn('integerAdd', (a: number, b: number) => a + b),
      ...deps,
    };
  }
}

type Factory = {
  name: string;
};

type FactoryList = Factory[];

const buildFactories = (factories: FactoryList) => {
  const factoryBatch = {};
  factories.forEach((factory) => {
    factoryBatch[factory.name] = factory;
  });
  return factoryBatch;
};

const intadd = { name: 'intadd', add: (a: number, b: number) => a + b };
const intsub = { name: 'intsub', add: (a: number, b: number) => a - b };

const ints = buildFactories([intadd, intsub]);

type type_int = atom<{ d: number; type: 'integer' }>;
type int_maker = (d: number) => type_int;
type type_real = atom<{ d: number; type: 'real' }>;
type real_maker = (d: number) => type_real;
type type_fraction = atom<{ d: number; type: 'fraction' }>;
type fraction_maker = (n: number, d: number) => type_fraction;

const int: int_maker = (d) => atom.of({ d, type: 'integer' });
const real: real_maker = (d) => atom.of({ d, type: 'real' });
const frac: fraction_maker = (n, d) => atom.of({ n, d, type: 'fraction' });


type Func<T = any> = (...args: T[]) => any;
const curry = (fn: Func, arity = fn.length, ...args: any[]): any =>
  arity <= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);
interface Integer {
  n: number;
  type: 'integer';
}
interface Real {
  n: number;
  type: 'real';
}
interface Rational {
  n: number;
  d: number;
  type: 'rational';
}
interface BigN {
  n: string;
  type: 'rational';
}
interface Vector {
  n: number[];
  type: 'vector';
}
interface Matrix {
  n: number[][];
  type: 'matrix';
}
interface Point2d {
  n: [number, number];
  type: 'point2d';
}
interface Point3d {
  n: [number, number, number];
  type: 'point3d';
}

class atom<t> {
  value: t;
  constructor(x: t) {
    this.value = x;
  }
  static of<t>(x: t) {
    return new atom<t>(x);
  }
  map<x>(f: (a: t) => x) {
    return atom.of(f(this.value));
  }
}

class box<t> extends atom<t> {
  value: t;
  constructor(x: t) {
    super(x);
    this.value = x;
  }
  get nil() {
    return this.value === null || this.value === undefined;
  }
  static of<t>(x: t) {
    return new box<t>(x);
  }
  map<x>(f: (a: t) => x) {
    return this.nil ? this : box.of(f(this.value));
  }
}


class val<t> {
  value: t;
  constructor(x: t) {
    this.value = x;
  }
  get nil() {
    return this.value === null || this.value === undefined;
  }
  static of<t>(x: t) {
    return new val<t>(x);
  }
  map<x>(f: (a: t) => x) {
    return this.nil ? this : val.of(f(this.value));
  }
}
interface semigroup<t> {
  value: t;
  concat(x: semigroup<t>): semigroup<t>;
}

interface monoid<t> extends semigroup<t> {
  id: () => monoid<t>;
}

class Sum implements monoid<number> {
  value: number;
  constructor(x: number) {
    this.value = x;
  }
  static id() {
    return new Sum(0);
  }
  static of(x: number) {
    return new Sum(x);
  }
  id() {
    return new Sum(0);
  }
  concat(x: Sum) {
    return new Sum(x.value + this.value);
  }
}

const sum = (x: number) => Sum.of(x);

const res = sum(5).concat(Sum.id());
console.log(res);

type semigroup<t> = {
  x: t;
  concat(x: semigroup<t>): semigroup<t>;
};




type monoid<t> = {
  x: t;
  id(): monoid<t>;
  concat(x: monoid<t>): monoid<t>;
};

const natsum = (x: number = 0): monoid<number> => ({
  x: Math.abs(Math.floor(x)),
  concat: (y) => natsum(x + y.x),
  id: () => natsum(0),
});

const natprod = (x: number = 1): monoid<number> => ({
  x: Math.abs(Math.floor(x)),
  concat: (y) => natprod(x * y.x),
  id: () => natprod(1),
});

const res = [1, 2, 3, 4, 5].map(natsum).reduce((a, n) => a.concat(n), natsum());
console.log(res);


class natural extends atom<number, 'natural'> {
  data: Data<number, 'natural'>;
  type: Numeric;
  constructor(n: number = 0) {
    super(n, 'natural');
    this.data = { value: n, type: 'natural' };
    this.type = 'natural';
  }
  static parse(n: string | number): number {
    if (is.number(n)) n = n.toString();
    const p = parse_natural(n);
    if (p.type === 'ERROR') return 0;
    return Number(p.result);
  }
  // static of(n: string | number) {
  // if (is.number(n)) return new natural(n);
  // return new natural(natural.parse(n));
  // }
}
class algebra<V extends Value, T extends Atom, O extends OpRecord> {
  public value: V;
  public name: T;
  public operators: OpRecord;
  constructor(n: V, t: T, ops: OpRecord = {}) {
    this.value = n;
    this.name = t;
    this.operators = { ...this.operators, ...ops };
  }
  get nil() {
    return this.value === null || this.value === undefined;
  }
  defineOp(ops: OpRecord) {
    this.operators = { ...this.operators, ...ops };
    return this;
  }
  static define<A extends Value, B extends Type, O2 extends OpRecord>(
    type: A,
    ops?: OpRecord
  ) {
    if (ops) return (value: A) => new algebra<A, B, O2>(value, type, ops);
    return (value: A) => new algebra<A, B, O2>(value, type);
  }
  map<V2 extends Value, T2 extends Type, O2 extends OpRecord>(
    fn: (a: V) => { value: V2; type: T2 }
  ): algebra<V, T, O> | algebra<V2, T2, O2> {
    if (this.nil) return this;
    const res = fn(this.value);
    return new algebra<V2, T2, O2>(res.value, res.type);
  }
  op(name: string) {
    if (name in this.operators) {
      return (a: V) =>
        new algebra<V, T, O>(
          this.operators[name](this.value, a),
          this.name,
          this.operators
        );
    }
    return (_: V) => this;
  }
}

const natural = algebra.define('natural', {
  ['+']: (a: number, b: number) => Math.abs(a + b),
  ['-']: (a: number, b: number) => Math.abs(a - b),
  ['*']: (a: number, b: number) => Math.abs(a * b),
  ['%']: (a: number, b: number) => Math.abs(a % b),
  ['/']: (a: number, b: number) => Math.floor(a / b),
});

const n = natural(5).op('+')(5);
console.log(n);

import { a, word, any, maybe } from '../../pcx/index.js';
import { show } from '../../pcx/util.js';

type NumberType = 'natural' | 'integer';

const is = {
  string: (x: any): x is string => typeof x === 'string',
  number: (x: any): x is number => typeof x === 'number',
  array: (x: any): x is any[] => Array.isArray(x),
  literal: (x: any) => typeof x === 'string' || typeof x === 'number',
};
const a_zero = a('0');

const pNatural = word(any('digit'))
  .or(a_zero)
  .map<string, string, NumberType>((d) => {
    let out = '';
    if (is.array(d.out)) {
      out = d.out.join('');
      let i = 0;
      while (out[i] === '0' && i < d.out.length) {
        out = out.slice(i + 1);
        i++;
      }
    } else {
      out = d.out;
    }
    return { out, type: 'natural' };
  });
const pInteger = word(maybe(a('-')), pNatural).map<string, string, NumberType>(
  (d) => ({
    out: d.out.join(''),
    type: 'integer',
  })
);

type Numeric = natural|integer|decimal|fraction|complex|real;

class numeric {
  constructor(public val: any) {
    this.val = val;
  }
}
class natural {}
class integer {}
class decimal {}
class fraction {}
class complex {}
class real {}

class Sym {
  symbol: string[];
  constructor(s: string) {
    this.symbol = [s];
  }
  get isTerminal() {
    return this.symbol.length === 1;
  }
  and(arg: Sym) {
    this.symbol = [...this.symbol, ...arg.symbol];
    return this;
  }
}

class Rule {
  private _name: string;
  private _body: Sym;
  constructor(name: string) {
    this._name = name;
  }
  is(def: Sym) {
    this._body = def;
    return { name: this._name, body: this._body };
  }
}

const rule = (s: string) => {
  return new Rule(s);
};

function grammar(...rules: any[]) {}

const a = (s: string) => new Sym(s);
const an = a;



const g = grammar(
  rule('SUM').is(an('a').and(a('+')).and(a('b'))),
);

class State {
  constructor(
    public grammar: Grammar,
    public progress: any,
    public columnIndex: number
  ) {
    this.grammar = grammar;
    this.progress = progress; // the red dot
    this.columnIndex = columnIndex; // the index of the column
  }
}

type Column = State[];

class Parser {
  chart: Column[];
  currentColumn:number;
  src: string;
  dot:number;
  constructor(src: string) {
    this.src = src;
    this.chart = [];
    this.currentColumn=0;
    this.dot=0;
  }
  
  /**
   * Returns the current symbol to parse.
   */
  get current() {return ""}
  
  /**
   * Returns true if the symbol is terminal,
   * false otherwise.
   */
  isTerminal(s:string) {
    return false;
  }
  
  set nextColumn(s:State) {
    this.currentColumn++;
    this.chart[this.currentColumn].push(s)
    this.dot++;
  }

  
  parse() {
    if (this.isTerminal(this.current)) {
      this.runScanner("")
    } else {
      this.runPredictor();
    }
  }
  get nextElement() {
    return ""
  }
  
  addStateToNextColumn(s:State) {
    this.nextColumn=s;
  }
  
  compare(a:string, b:string) {
    if (a === b) this.addStateToNextColumn(state)
  }
  
  runScanner(s:string) {
    this.compare(s, this.nextElement)
  }
  runPredictor() {
  }

  /**
   * Three operations are used to fill in the chart.
   */
  scan() {}
  predict() {}
  complete() {}
}

/**
 *
 *
 * If we parse '1 + 2', we get a chart
 * that looks like.
 * The dot is the progress property.
 * Each column is a set of states.
 * The column index tells us where the rule started to match.
 *
 * | •1+2          | 1•+2          | 1+•2          | 1+2•          |
 * | progress:    0| progress:    1| progress:    2| progress:    3|
 * | columnix:    0| columnix:    1| columnix:    2| columnix:    3|
 * | grammar       | grammar:     1| grammar:     2| grammar:     3|
 *
 */

const insertChar = (s: string, c: string, i: number) => {
  return s.slice(0, i) + c + s.slice(i);
};

class sym {
  constructor(public symbol: string, public isTerminal: boolean) {
    this.symbol = symbol;
    this.isTerminal = isTerminal;
  }
}

const nt = (symbol: string) => new sym(symbol, false);
const t = (symbol: string) => new sym(symbol, true);
type nonterminal = ReturnType<typeof nt>;
type terminal = ReturnType<typeof t>;

// type Rule = [string, sym[]];

class Rule {
  name: string;
  definition: sym[];
  constructor(name: string, definition: sym[]) {
    this.name = name;
    this.definition = definition;
  }
}

const rule = (name: string, def: sym[]) => new Rule(name, def);

type Rules = Rule[];
type State = { name: string; body: string; dot: number; column: number };
type GrammarList = { name: string; body: string }[];

class Grammar {
  grammarList: GrammarList;
  dot: number;
  nonterminals: Set<string>;
  s: Set<State>[];
  #logs: Set<string>[];
  hist: string[];
  src: string;
  constructor(grammar: Rules) {
    this.dot = 0;
    this.#logs = [];
    this.hist = [];
    this.nonterminals = new Set<string>();
    this.grammarList = [];
    for (let i = 0; i < grammar.length; i++) {
      const r = grammar[i];
      const ruleName = r.name;
      const grammarRule = { name: ruleName };
      this.nonterminals.add(ruleName);
      let rule = '';
      for (let j = 0; j < r.definition.length; j++) {
        const s = r.definition[j];
        rule += s.symbol;
        if (!s.isTerminal) this.nonterminals.add(s.symbol);
      }
      grammarRule['body'] = rule;
      this.grammarList.push(grammarRule as { name: string; body: string });
    }
  }
  string_set_array_of_length(n: number) {
    let out: Set<string>[] = [];
    for (let i = 0; i < n; i++) {
      out.push(new Set());
    }
    return out;
  }
  sets_array_of_length(n: number) {
    let out: Set<State>[] = [];
    for (let i = 0; i < n; i++) {
      out.push(new Set());
    }
    return out;
  }

  isNotAtEndOf(state: State) {
    return state.body[state.dot] !== undefined;
  }
  nextElementOf(state: State) {
    const d = state.dot;
    const out = state.body[this.dot];
    return out;
  }
  isTerminal(sym: string) {
    return !this.nonterminals.has(sym);
  }

  predictor = (state: State, columnIdx: number) => {
    const name = state.body[state.dot];
    for (let i = 0; i < this.grammarList.length; i++) {
      const r = this.grammarList[i];
      if (r.name === name) {
        const st = { ...r, dot: this.dot, column: columnIdx };
        const string_st = JSON.stringify(st);
        if (!this.#logs[columnIdx].has(string_st)) {
          this.record(st, this.dot, columnIdx);
          this.#logs[columnIdx].add(JSON.stringify(st));
          this.s[columnIdx].add(st);
        }
      }
    }
  };
  scanner = (state: State, columnIdx: number) => {
    const match = state.body === this.src[columnIdx];
    if (match) {
      this.dot += 1;
      const res = { ...state, dot: this.dot };
      this.#logs[columnIdx + 1].add(JSON.stringify(res));
      this.record(res, this.dot, columnIdx);
      this.s[columnIdx + 1].add(res);
    }
    return 1;
  };
  record(state: State, dot: number, column: number) {
    const cd =
      state.name + ' => ' + insertChar(state.body, '•', dot) + ` S(${column})`;
    this.hist.push(cd);
  }
  completor = (state: State, k: number) => {
    const lastMatch = state.column;
    const lastMatchName = state.name;
    const lastMatchDot = state.dot;
    const lastMatchStates = this.s[lastMatch];
    let out: any[] = [];
    for (state of lastMatchStates.values()) {
      if (state.body[lastMatchDot - 1] === lastMatchName) {
        this.record(state, lastMatchDot, lastMatch);
        const st = { ...state, dot: lastMatchDot };
        out.push(st);
      }
    }
  };
  parse(src: string) {
    this.src = src;
    const L = src.length;
    this.s = this.sets_array_of_length(L);
    this.#logs = this.string_set_array_of_length(L);
    const st = { ...this.grammarList[0], dot: this.dot, column: 0 };
    this.#logs[0].add(JSON.stringify(st));
    this.record(st, 0, 0);
    this.s[0].add(st);
    for (let columnIdx = 0; columnIdx < L; columnIdx++) {
      for (const state of this.s[columnIdx]) {
        if (this.isNotAtEndOf(state)) {
          if (this.isTerminal(this.nextElementOf(state))) {
            this.scanner(state, columnIdx);
            // return this.s;
          } else {
            this.predictor(state, columnIdx);
          }
        } else {
          this.completor(state, columnIdx);
        }
      }
    }
    return this.s;
  }
}

const _grammar = new Grammar([
  rule('term', [nt('number'), t('+'), nt('number')]),
  rule('term', [t('number')]),
  rule('number', [t('1')]),
]);
const res = _grammar.parse('1+1');
console.log(_grammar);
//

class Parser {
  nonterminals: Set<string>;
  rules: GrammarRule[];
  src: string;
  states: StateObj[][];
  uniqueStates: Set<string>;
  currentColumn: number;
  inputLength: number;
  parsed: string[];
  constructor(grammar: Grammar) {
    this.nonterminals = grammar.nonterminals;
    this.parsed = [];
    this.uniqueStates = new Set();
    this.rules = grammar.rules;
    this.currentColumn = 0;
    this.states = [];
  }
  static of(grammar: Grammar) {
    return new Parser(grammar);
  }
  parse(src: string) {
    this.src = src;
    this.inputLength = src.length;
    this.states = new Array(src.length)
      .fill([])
      .map((_, i) =>
        i === 0 ? [enstate(this.rules[0], 0, this.currentColumn)] : []
      );
    for (let column = 0; column < this.inputLength; column++) {
      for (const _state of this.states[column]) {
        if (this.isNotAtEnd(_state)) {
          if (this.isTerminal(this.nextElementOfState(_state))) {
            this.scan(_state, this.src[column]);
          } else {
            this.predict(_state);
          }
        } else {
          this.complete(_state);
        }
      }
    }
    return this.states;
  }
  scan(_state: StateObj, element: string) {
    const stateRuleBody = _state.rule;
    let out: any[] = [];
    let i: number;
    for (i = 0; i < stateRuleBody.length; i++) {
      if (element === stateRuleBody[i]) {
        out.push(element);
        this.parsed.push(element);
      }
    }
    const newState = enstate(
      _state.matchedRule,
      _state.dot + _state.rule.length,
      this.currentColumn,
      true,
    );
    this.uniqueStates.add(newState.body);
    this.states[this.currentColumn].push(newState);
    this.currentColumn += element.length;
  }
  predict(_state: StateObj) {
    this.uniqueStates.add(_state.body);
    const name = _state.rule[_state.dot];
    for (let i = 0; i < this.rules.length; i++) {
      const rule = this.rules[i];
      if (rule.name === name) {
        const matchedState = enstate(rule, _state.dot, this.currentColumn);
        if (!this.uniqueStates.has(matchedState.body)) {
          this.states[this.currentColumn].push(matchedState);
        }
        this.uniqueStates.add(matchedState.body);
      }
    }
  }
  complete(_state: StateObj) {
    const previousColumn = this.states[_state.lastMatchedColumn];
    const name = _state.name;
    const out: any = [];
    for (let i = 0; i < previousColumn.length; i++) {
      const stateEntry = previousColumn[i];
      if (stateEntry.rule[stateEntry.dot] === name) {
        const newState = enstate(
          stateEntry.matchedRule,
          stateEntry.dot + 1,
          stateEntry.lastMatchedColumn,
        );
        this.uniqueStates.add(newState.body);
        this.states[this.currentColumn].push(newState);
        out.push(newState);
      }
    }
  }
  nextElementOfState(_state: StateObj): string {
    return _state.rule[_state.dot];
  }
  isTerminal(element: string) {
    return !this.nonterminals.has(element);
  }
  isNotAtEnd(_state: StateObj) {
    return _state && _state.rule && _state.rule[_state.dot] !== undefined;
  }
}

const parser = Parser.of(addition);
parser.parse("2+3*4");
console.log(parser);


const enstate = (
  rule: GrammarRule,
  dot: number,
  matchedColumn: number,
  terminal = false,
) => new StateObj(rule, dot, matchedColumn, terminal);



// const initState = (grammar: Grammar): State => {
// const rules = grammar.rules.map((d) => d.name + " => " + d.rule.join(" "));
// let states = new Set<string>();
// rules.forEach((d) => states.add(d));
// return { ...grammar, states: [states] };
// };

// type State = { nonterminals: Set<string>; rules: GrammarRule[] };
// const setDot = (grammar: Grammar, rule: number, at: number): Grammar => {
// const _rule = grammar.rules[rule];
// const _item = [..._rule.item.slice(0, at), "•", ..._rule.item.slice(at)];
// const _rules: GrammarRule[] = grammar.rules.map((d, i) =>
// i === rule ? ({ ...d, item: _item }) : ({ ...d })
// );
// return { ...grammar, rules: _rules };
// };

// const dottedG = setDot(G, 2, 1);
// log(dottedG);
// const sG = setState(G);
// log(sG)











type StateEntry = (string | string[])[];
type State = {
  item: StateEntry;
  dot: number;
  column: number;
  seen: Set<string>;
};
type ParseState = Grammar & { state: State[] };

const initState = (grammar: Grammar, setCount: number): ParseState => {
  const _rule = grammar.rules[0];
  const _item = ["•", ..._rule.item];
  let stateEntry: StateEntry = _item;
  const _seen = _item.reduceRight((_) =>
    _rule.name + " => " + _item.join(" ")
  ) as string;
  const state: State = {
    item: stateEntry,
    dot: 0,
    column: 0,
    seen: new Set<string>().add(_seen),
  };
  const stateList = [state];
  for (let i = 0; i < setCount; i++) {
    stateList.push({} as any);
  }
  return {
    ...grammar,
    state: stateList,
  };
};

const isNotAtEnd = (s: State) => {
  const item = s.item;
  console.log(item);
  const dot = s.dot;
  return item[dot + 1] !== undefined;
};
const nextElementOf = (s: State) => {
  // console.log(s.items);
  // console.log(s.items[s.column]);
  // console.log(s.items[s.column][s.dot]);
  // return 8;
};

const scan = () => ({});
const predict = () => ({});
const complete = () => ({});

function parse(grammar: Grammar, input: string) {
  const states = initState(grammar, input.length);
  for (let i = 0; i < input.length; i++) {
    
    // for (const state of states.state[i]) {
    // console.log(state)
    // }
    // let currentState = states[i];
  }
  return states;
}

const res = parse(G, "1+1");
// display(res);
log(res);

class StateObj {
  constructor(
    public rule: GrammarRule,
    public dot: number,
    public matchedColumn: number,
    public terminal: boolean,
  ) {
    this.rule = rule;
    this.dot = dot;
    this.matchedColumn = matchedColumn;
    this.terminal = terminal;
  }
}

const enstate = (
  rule: GrammarRule,
  dot: number,
  matchedColumn: number,
  terminal = false,
) => new StateObj(rule, dot, matchedColumn, terminal);

class Parser {
  nonterminals: Set<string>;
  rules: GrammarRule[];
  src: string;
  states: StateObj[][];
  uniqueStates: Set<string>;
  currentColumn: number;
  inputLength: number;
  parsed: string[];
  constructor(grammar: Grammar) {
    this.nonterminals = grammar.nonterminals;
    this.parsed = [];
    this.uniqueStates = new Set();
    this.rules = grammar.rules;
    this.currentColumn = 0;
    this.states = [];
  }
  static of(grammar: Grammar) {
    return new Parser(grammar);
  }
  parse(src: string) {
    this.src = src;
    this.inputLength = src.length;
    this.states = new Array(src.length)
      .fill([])
      .map((_, i) =>
        i === 0 ? [enstate(this.rules[0], 0, this.currentColumn)] : []
      );
    for (let column = 0; column < this.inputLength; column++) {
      for (const _state of this.states[column]) {
        if (this.isNotAtEnd(_state)) {
          if (this.isTerminal(this.nextElementOfState(_state))) {
            this.scan(_state, this.src[column]);
          } else {
            this.predict(_state);
          }
        } else {
          this.complete(_state);
        }
      }
    }
    return this.states;
  }
  scan(_state: StateObj, element: string) {
    const stateRuleBody = _state.rule;
    let out: any[] = [];
    let i: number;
    for (i = 0; i < stateRuleBody.length; i++) {
      if (element === stateRuleBody[i]) {
        out.push(element);
        this.parsed.push(element);
      }
    }
    const newState = enstate(
      _state.matchedRule,
      _state.dot + _state.rule.length,
      this.currentColumn,
      true,
    );
    this.uniqueStates.add(newState.body);
    this.states[this.currentColumn].push(newState);
    this.currentColumn += element.length;
  }
  predict(_state: StateObj) {
    this.uniqueStates.add(_state.body);
    const name = _state.rule[_state.dot];
    for (let i = 0; i < this.rules.length; i++) {
      const rule = this.rules[i];
      if (rule.name === name) {
        const matchedState = enstate(rule, _state.dot, this.currentColumn);
        if (!this.uniqueStates.has(matchedState.body)) {
          this.states[this.currentColumn].push(matchedState);
        }
        this.uniqueStates.add(matchedState.body);
      }
    }
  }
  complete(_state: StateObj) {
    const previousColumn = this.states[_state.lastMatchedColumn];
    const name = _state.name;
    const out: any = [];
    for (let i = 0; i < previousColumn.length; i++) {
      const stateEntry = previousColumn[i];
      if (stateEntry.rule[stateEntry.dot] === name) {
        const newState = enstate(
          stateEntry.matchedRule,
          stateEntry.dot + 1,
          stateEntry.lastMatchedColumn,
        );
        this.uniqueStates.add(newState.body);
        this.states[this.currentColumn].push(newState);
        out.push(newState);
      }
    }
  }
  nextElementOfState(_state: StateObj): string {
    return _state.rule[_state.dot];
  }
  isTerminal(element: string) {
    return !this.nonterminals.has(element);
  }
  isNotAtEnd(_state: StateObj) {
    return _state && _state.rule && _state.rule[_state.dot] !== undefined;
  }
}

class Chart<t> {
  #keyprefix: string;
  keycount: number;
  data: { [key: string]: t[] };
  seen: Set<string>;
  current: number;
  keynow: string;
  constructor(keyprefix: string, initialData?: t[], count = 1) {
    this.#keyprefix = keyprefix;
    this.keycount = count;
    this.seen = new Set<string>();
    this.data = {} as { [key: string]: t[] };
    for (let i = 0; i < count; i++) {
      this.data[`${this.#keyprefix}${i}`] = [];
    }
    if (initialData) {
      this.data[`${this.#keyprefix}${0}`] = initialData;
      for (let i = 0; i < initialData.length; i++) {
        this.record(initialData[i]);
      }
    }
    this.current = 0;
    this.keynow = this.#keyprefix + this.current;
  }

  /** Returns the current key. */
  private get currentKey() {
    this.keynow = this.#keyprefix + this.current;
    return this.keynow;
  }

  /** Records a value added. */
  private record<t>(value: t) {
    const v = JSON.stringify(value);
    this.seen.add(v);
  }

  /** Pushes a value to to the current key. */
  push(...value: t[]) {
    for (let i = 0; i < value.length; i++) {
      this.record(value[i]);
      this.data[this.currentKey].push(value[i]);
    }
    return this;
  }

  /** Moves to the next key. */
  nextKey() {
    if (this.keycount <= this.current + 1) {
      this.current += 1;
      this.keycount += 1;
      this.data[this.currentKey] = [] as t[];
    } else {
      this.current += 1;
    }
    return this;
  }

  /** Moves to the previous key. */
  prevKey() {
    this.current -= 1;
    return this;
  }
  loop(fn: (d: t, index: number) => t) {
    for (let i = 0; i < this.keycount; i++) {
      const k = `${this.#keyprefix}${i}`;
      const currentRow = this.data[k];
      const out: t[] = [];
      for (let j = 0; j < currentRow.length; j++) {
        out.push(fn(currentRow[j], j));
      }
			this.data[k] = out;
    }
    return this;
  }
}



const chart = <T>(keyprefix: string, intitialData?: T[], count = 1) =>
  new Chart<T>(keyprefix, intitialData, count);

const x = chart("s", [1, 2, 3]).nextKey().push(5).push(10).loop(d=>d**2);

console.log(x);

const node = <t>(value: t | null, tag: string | number | null, color?: Color) =>
  new RBN<t>(value, color, tag);

const defc = (a: number, b: number) => a > b;
const deft = <t>(a: t) => JSON.stringify(a);

class RedBlackTree<t> {
  root: RBN<t | null>;
  cmp: CompFn<t>;
  tagfn: TagFunction<t>;
  constructor(cmp: CompFn<t> = defc, tagfn: TagFunction<t> = deft) {
    this.tagfn = tagfn;
    this.root = node(null, null);
    this.cmp = cmp;
  }
  addNode(value: t) {
    const tag = this.tagfn(value);
    const nullNode = node(value, this.tagfn(value));
    const newNode = node(value, this.tagfn(value), Color.red);
    if (this.root.isNull) this.root = nullNode;
    else {
    }
    return this;
  }
}

const redBlackTree = () => new RedBlackTree();

const rbt = redBlackTree();

console.log(rbt);

enum Color {
  red = "red",
  black = "black",
}

type TagType = string|number|null;

class rbNode<t> {
  left: rbNode<t|null> | null;
  right: rbNode<t|null> | null;
  Value: t | null;
  Color: Color;
  Tag: TagType;
  constructor(value:t|null=null, tag:TagType, color=Color.black) {
    this.left = new rbNode(null,null);
    this.right = new rbNode(null,null);
    this.Value = value;
    this.Color = color;
    this.Tag = tag;
  }
  get value() { return this.Value; }
  get color() { return this.Color; }
  get tag() { return this.Tag; }
  get leftChild() { return this.left; }
  get rightChild() { return this.right; }
  get hasLeftChild() { return this.left !== null; }
  get hasRightChild() { return this.right !== null; }
  get isNull() { return this.value === null; }
  get isRed() { return this.color === Color.red; }
  get isBlack() { return this.color === Color.black; }
  setRightChild(node: rbNode<t>) {
    this.right = node;
    return this;
  }
  setLeftChild(node: rbNode<t>) {
    this.left = node;
    return this;
  }
}
const node = <t>(value:t, tag:TagType, color?:Color) => new rbNode<t>(value, tag, color);

type ObjCmp<R> = (a: keyof R, b: keyof R) => boolean;
type NumCmp = (a: number, b: number) => boolean;
type StrCmp = (a: string, b: string) => boolean;
type Cfn<t> = ObjCmp<t> | NumCmp | StrCmp;
type Tfn<t> = (d: t) => string | number;
const defc = (a: string, b: string) => a > b;
const deft = <t>(a:t) => {
  if (typeof a === 'number') return a;
  else if (typeof a === 'string') return a;
  else return (Math.random()*1000);
};

const x = deft('hello');


class RedBlackTree<t> {
  compare: Cfn<t>;
  tag: Tfn<t>;
  root: rbNode<t>|rbNode<null>;
  constructor(data?:t[], cmp:Cfn<t> = defc, tfn?:Tfn<t>) {
    this.compare=cmp;
    this.tag = tfn !== undefined ? tfn : deft;
    this.root = node(null, null);
  }
}

const redBlackTree = <t>(data?:t[], cmp?:Cfn<t>, tfn?:Tfn<t>) => new RedBlackTree(data, cmp, tfn);

const rbt = redBlackTree();
console.log(rbt);


type NODE<T> = TreeNode<T> | TreeNode<null> | null;

class TreeNode<T> {
  value: T;
  left: NODE<T>;
  right: NODE<T>;
  color: color;
  constructor(value: T, color: color, left: NODE<T>, right: NODE<T>) {
    this.value = value;
    this.color = color;
    this.left = left;
    this.right = right;
  }
}

class BlackNode<t> extends TreeNode<t | null> {
  constructor(value: t | null, tag: string | number | null = null) {
    super(value, color.black, null, null);
  }
}

class RedNode<T> extends TreeNode<T> {
  constructor(value: T) {
    super(value, color.red, new BlackNode(null), new BlackNode(null));
  }
}

const rednode = <t>(value: t) => new RedNode(value);
const blacknode = <t>(value: t | null = null) => new BlackNode(value);

type ObjCmp<t> = (a: t, b: t) => boolean;
class RedBlackTree<t> {
  root: BlackNode<t | null>;
  #comparer: ObjCmp<t>;
  public constructor(cmp: ObjCmp<t>) {
    this.root = blacknode(null);
    this.#comparer = cmp;
  }
  push(value: t) {
    if (this.root.value === null) {
      this.root = blacknode(value);
    } else {
      const nullchild = blacknode(null);
    }
    return this;
  }
}
const redBlackTree = <t>(fn: ObjCmp<t>) => new RedBlackTree(fn);

const rbt = redBlackTree((a: number, b: number) => a > b);

const j = rbt.push(5);

console.log(j);

enum Color {
  red = "red",
  black = "black",
}

class Nilnode {
  value: null;
  left: null;
  right: null;
  color: Color;
  constructor() {
    this.value = null;
    this.left = null;
    this.right = null;
    this.color = Color.black;
  }
}

const nilnode = () => new Nilnode();

class Rbnode<t> {
  value: t;
  color: Color;
  left: Rbnode<t> | Nilnode;
  right: Rbnode<t> | Nilnode;
  constructor(
    value: t,
    color: Color,
    left: Rbnode<t> | Nilnode,
    right: Rbnode<t> | Nilnode,
  ) {
    this.value = value;
    this.color = color;
    this.left = left;
    this.right = right;
  }
}
class Blacknode<t> extends Rbnode<t> {
  constructor(value: t) {
    super(value, Color.black, nilnode(), nilnode());
    this.value = value;
  }
}
const blacknode = <t>(val: t) => new Blacknode(val);
class Rednode<t> extends Rbnode<t> {
  constructor(value: t) {
    super(value, Color.red, nilnode(), nilnode());
    this.value = value;
  }
}
const rednode = <t>(val: t) => new Rednode(val);
const isRednode = (n: any) => n instanceof Rednode;
const isBlacknode = (n: any) => n instanceof Blacknode;
const isNilnode = (n: any) => n instanceof Nilnode;
const isnil = (n: any) => n === undefined || n === null;

type anode<t> = Rbnode<t> | Blacknode<t> | Nilnode;
type Cmpfn<t> = (a: t, b: t) => boolean;
class Rbtree<t> {
  compare: Cmpfn<t>;
  root: Blacknode<t> | Nilnode;
  constructor(compare: Cmpfn<t>, initialValue?:t) {
    this.compare = compare;
    this.root = initialValue!==undefined ? blacknode(initialValue) : nilnode();
  }
  push(value: t) {
    if (isNilnode(this.root)) {
      return new Rbtree(this.compare, value);
    }
    const correctRight = (node:anode<t>, value:t) => {
    }
    const insert = (node:anode<t>|null, value:t) => {
      const nullchild = nilnode();
      const newnode = rednode(value);
      if (node===null) return newnode;
      if (node===undefined) return newnode;
      if (node.value===null) return newnode;
      if (node.value===undefined) return newnode;
      if (node.right===undefined) return newnode;
      else if (this.compare(value, node.value)) {
        node.right = insert(node.right, value);
        if (node.color===Color.red) return node;
        // else if (node.right.color===Color.red) return correctRight(node,value);
        else return newnode;
      }
      else return newnode;
    }
  }
}

const redBlackTree = <t>(cfn: Cmpfn<t>) => new Rbtree<t>(cfn);

const rbt = redBlackTree((a: number, b: number) => a > b);

rbt.push(10);

interface iBinaryTree<t> {
  compare: compareFn<t>;
  root: tnode<t>;
  preorder(this: iBinaryTree<t>, fn: (nodeval: t) => t): this;
  inorder(this: iBinaryTree<t>, fn: (nodeval: t) => t): this;
  postorder(this: iBinaryTree<t>, fn: (nodeval: t) => t): this;
}
function binaryTree<t, r extends Settings<t>>(settings: Settings<t> & r) {
  return function (root: tnode<t>): iBinaryTree<t> & r {
    const compare = settings.compare;
    return {
      ...settings,
      root,
      compare,
      push(this: iBinaryTree<t>, val: tnode<t>) {
        return this;
      },
      preorder(this: iBinaryTree<t>, fn: (nodeval: t) => t) {
        return this;
      },
      inorder(this: iBinaryTree<t>, fn: (nodeval: t) => t) {
        return this;
      },
      postorder(this: iBinaryTree<t>, fn: (nodeval: t) => t) {
        return this;
      },
    };
  };
}

const bst = binaryTree({
  compare: (a: number, b: number) => a < b,
});

const b1 = bst(node(10));

import {
  asMany,
  chain,
  letter,
  lit,
  maybe,
  numeral,
  oneof,
} from "./parsers/pkt/index.js";
const { log: print } = console;

const natural = asMany(...numeral.slice(1)).maybe(numeral[0]).type("natural");
const dash = lit("-");
const negInt = chain(dash, natural).type("integer");
const int = chain(natural.or(negInt)).type("integer");
const dot = lit(".");
const float = chain(int, dot, maybe(asMany(numeral[0])), natural).type("float");
const fslash = lit("/");
const rational = chain(float.or(int), fslash, float.or(int)).type("rational");
const scientific = chain(float.or(int), letter.E, float.or(int)).type(
  "scientific",
);
const numeric = oneof(scientific, rational, float, int);

const ERROR = Symbol("ERROR");
type Err = typeof ERROR;
type ErrNode = { value: string; type: Err };
type NumberNode = { value: string; type: string };
type Node = NumberNode | ErrNode;


const { log: show } = console;
class St {
  constructor(public value: string, public log: string[] = []) {
    this.value = value;
    this.log = log || [];
  }
  bind(fn: (s: string) => string) {
    let value = fn(this.value);
    return new St(value, [...this.log, this.value]);
  }
}

const x = new St("abcd")
  .bind((s) => s.toUpperCase())
  .bind((s) => s.charAt(1))
  .bind((s) => s.toLowerCase());

const nil = Symbol("nil");
type Nil = typeof nil;
const isnil = (v: any): v is Nil => v === nil;

class Opt<t> {
  constructor(public value: t | Nil) {
    this.value = value;
  }
  map<y>(fn: (a: t) => y): Opt<t | y> {
    return isnil(this.value) ? this : new Opt(fn(this.value));
  }
}

function markPosition(
  rules: FormattedRule[],
  ruleIndex: number,
  position: number,
  ruleName: string,
) {
  const update = rules[ruleIndex][ruleName].map((s, i) =>
    i === position ? "•" : s
  );
  return rules.map((r, i) => i === ruleIndex ? { [ruleName]: update } : r);
}
const grammar = Grammar(
  { P: ["S"] },
  { S: ["S", lit("+"), "M"] },
  { S: ["M"] },
  { M: ["M", lit("*"), "T"] },
  { M: ["T"] },
  { T: [num("integer")] },
);

type SetArg = { set: number };
type SetListOpArgs<t> = SetArg & { val: t };
function setList<t>(count: number) {
  const sets: Set<t>[] = [];
  for (let i = 0; i < count; i++) sets.push(new Set<t>());
  return {
    sets,
    insert({ set, val }: SetListOpArgs<t>) {
      this.sets[set].add(val);
      return this;
    },
    remove({ set, val }: SetListOpArgs<t>) {
      if (this.sets[set].has(val)) {
        this.sets[set].delete(val);
      }
      return this;
    },
    clear({ set }: SetArg) {
      this.sets[set].clear();
      return this;
    },
    read({ set }: SetArg) {
      return Array.from(this.sets[set]);
    },
  };
}

type Rule = { [key: string]: (string | P<string>)[] };
function Grammar(...rules: Rule[]) {
  const nonterminals = new Set<string>();
  const forms: any[] = [];
  const name = (rule: Rule) => Object.keys(rule)[0];
  const formatRule = (rule: Rule) => {
    let rulename = name(rule);
    let body = Object.values(rule)[0].map((v) => v instanceof P ? v.type : v);
    return [rulename, body];
  };
  rules.forEach((r) => nonterminals.add(name(r)));
  rules.forEach((r) => {
    forms.push(formatRule(r));
  });
  return {
    rules,
    nonterminals,
    forms,
  };
}
type GrammarObj = ReturnType<typeof Grammar>;
type FRule = [string, string[]];
type PushProps = { rule: number; column: number; dot: "left" | "right" };
function Parser(grammar: GrammarObj) {
  const name = (rule: Rule) => Object.keys(rule)[0];
  function stateSet(source: string) {
    const setlist = setList<string>(source.length);
    const formatrule = (rule: string[], dot: number) => {
      let r = [...rule.slice(0, dot), "•", ...rule.slice(dot)].join("");
      return r;
    };
    return {
      states: setlist,
      pushStringRule(
        { rule, column, dot }: {
          rule: string;
          column: number;
          dot: "left" | "right";
        },
      ) {
        const pos = dot === "left" ? 0 : rule.length;
        const stringRule = formatrule([rule.slice(1)], pos);
        if (column < this.states.sets.length) {
          this.states.insert({ set: column, val: stringRule });
        }
        return this;
      },
      push({ rule, column, dot }: PushProps) {
        const pos = dot === "left" ? 0 : grammar.forms[rule][1].length;
        const stringRule = formatrule(grammar.forms[rule][1], pos);
        if (column < this.states.sets.length) {
          this.states.insert({ set: column, val: stringRule });
        }
        return this;
      },
    };
  }
  function isNotAtEnd(s: string) {
    for (let i = 0; i < s.length; i++) {
      if (s[i] === "•" && i < s.length - 1) return true;
    }
    return false;
    k;
  }
  function getNextElement(s: string) {
    return [...s].reduce((p, c, i) => c === "•" ? p + s[i + 1] : p, "");
  }
  function isTerminal(s: string) {
    return !grammar.nonterminals.has(s);
  }
  function getBody(rule: Rule) {
    return Object.values(rule)[0];
  }
  function getParser(k: number): P<string> | null {
    const body = getBody(grammar.rules[k + 1]).filter(
      (v, i) => v instanceof P && i === k + 1,
    )[0];
    if (body === undefined) return null;
    return body as P<string>;
  }
  function parse(source: string) {
    const s = stateSet(source).push({ rule: 0, column: 0, dot: "left" });
    function scan(state: string, k: number) {
      const parser = getParser(k);
      if (parser !== null) {
        const res = parser.run(source[k + 1]);
        const ri = grammar.rules.indexOf(grammar.rules[k + 1]);
        show(state);
        if (!res.err) {
          s.pushStringRule({ rule: state, column: k + 1, dot: "right" });
        }
      }
    }
    function predict(state: string, k: number) {
      const term = getNextElement(state);
      show(state);
      grammar.rules.forEach((r, i) => {
        if (name(r) === term) s.push({ rule: i, column: k, dot: "left" });
      });
    }
    const complete = (state: string) => {};

    for (let k = 0; k < source.length; k++) {
      for (let state of s.states.sets[k]) {
        if (isNotAtEnd(state)) {
          if (isTerminal(getNextElement(state))) {
            scan(state, k);
          } else predict(state, k);
        } else {
          complete(state);
        }
      }
    }
    return { s, grammar };
  }
  return { parse };
}

const parser = Parser(grammar);
show(parser.parse("2+3*4"));









const initState = (source:string) => ({
  index: 0,
  token: "",
  source,
});
type State = ReturnType<typeof initState>;
function Parser() {
  const str = (S: State, end: number) => S.source.slice(S.index, end);
  const charprev = (S: State) => S.source.charAt(S.index - 1);
  const charnow = (S: State) => str(S, 1);
  const charnext = (S: State) => S.source.charAt(S.index + 1);
  const tick = (S: State) => S.index += 1;
  function parse(src: string) {
    const state = initState(src);
    token(state);
    return state;
  }
  function token(state:State) {
    state.token=charnow(state)
  }
  return { parse };
}



const parser = Parser();
const parsing = parser.parse("1+2");
show(parsing);






type KeyVal<T, V> =
  & keyof { [P in keyof T as T[P] extends V ? P : never]: P }
  & keyof T;

type Rules = {
  [key: string]: (string | P<string>)[];
};

function objval<t extends Object>(k: t) {
  return Object.values(k)[0];
}

function objkey<t extends Object>(k: t) {
  return Object.keys(k)[0];
}

function dedupe<t>(arr: t[]) {
  return Array.from(new Set(arr));
}
type Strp = string | P<string>;

function Grammar<t, v>(...rules: Rules[]) {
  const nonterminals = dedupe(rules.map((r) => objkey(r)));
  const ruleBodies: ([string, string])[] = rules.map(
    (r) => [
      objkey(r),
      objval(r).map((d: Strp) => d instanceof P ? d.type : d).join(""),
    ],
  );
  return ({ rules, ruleBodies, nonterminals });
}

const grammar = Grammar(
  { P: ["S"] },
  { S: ["S", lit("+"), "M"] },
  { S: ["M"] },
  { M: ["M", lit("*"), "T"] },
  { M: ["T"] },
  { T: [num("integer")] },
);

type GrammarObj = ReturnType<typeof Grammar>;
type StateSet = Set<string>;

function Parser(grammar: GrammarObj) {
  const isnonterminal = (s: string) => grammar.nonterminals.includes(s);
  const isterminal = (s: string) => !isnonterminal(s);
  const initsets = (count: number) => {
    let states = [];
    for (let i = 0; i < count; i++) states.push(new Set<string>());
    return states;
  };
  const notEnd = (state: string) => {
    return state.indexOf("•") !== state.length - 1;
  };
  const nextElement = (state: string) => {
    return state[state.indexOf("•") + 1];
  };
  const addRule = (
    ruleIndex: number,
    s: StateSet,
    pos: number,
    dot: number,
  ) => {
    const ruleBody = grammar.ruleBodies[ruleIndex];
    const rr = [...ruleBody[1].slice(0, dot), "•", ...ruleBody[1].slice(dot)]
      .join("");
    s.add(rr);
  };
  function parse(src: string) {
    const S = initsets(src.length);
    let setIndex = 0;
    addRule(0, S[setIndex], 0, 0);
    const scan = (state:string, k:number) => {
      show('in scanner')
    };
    const predict = (state: string, k: number) => {
      const term = nextElement(state);
      let i = 0;
      for (const rule of grammar.rules) {
        if (objkey(rule) === term) {
          addRule(i, S[setIndex], k, 0);
        }
        i++;
      }
    };
    const complete = () => {};
    for (let k = 0; k < src.length; k++) {
      for (let state of S[k]) {
        if (notEnd(state)) {
          if (isterminal(nextElement(state))) {
            scan(state, k);
          } else predict(state, k);
        } else complete();
      }
    }
    return { src, grammar, S };
  }
  return { parse };
}
const parser = Parser(grammar).parse("2+3*4");

show(parser);




function rules(symbol: string, expansion: (string | P<string>)[]) {
  return new Rule(symbol, expansion);
}
const r1 = rules("P", ["P", lit("+"), "T"]);
const c1 = chart(5);
r1.setDot(0);
c1.insert({ entry: r1.print, setNumber: 0 });
show(c1.print(0));

class Rule {
  public expansion: (string | P<string>)[];
  public symbol: string;
  constructor(symbol: string, expansion: (string | P<string>)[]) {
    this.symbol = symbol;
    this.expansion = expansion;
  }
}

class Chart {
  public chart: State[][];
  public lastAddedState: State | null;
  constructor(columns: number) {
    this.chart = [];
    for (let i = 0; i < columns; i++) {
      this.chart.push([]);
    }
    this.lastAddedState = null;
  }
  get sets() {
    return this.chart;
  }
  insert({ entry, setNumber }: InsertArgs) {
    const stateColumn = this.chart[setNumber];
    for (let i = 0; i < stateColumn.length; i++) {
      const state = stateColumn[i];
      if (state.rule === entry.rule) {
        return;
      }
    }
    this.chart[setNumber].push(entry);
    this.lastAddedState = entry;
  }
  allFrom({ setNumber, asArray = true }: allFromArgs) {
    return asArray ? this.chart[setNumber] : Array.from(this.chart[setNumber]);
  }
  entryCount({ setNumber }: entryCountArgs) {
    return this.chart[setNumber].length;
  }
  print(column: number) {
    let str = "";
    str += "--------------------------\n";
    str += `Column: ${column}\n`;
    for (const entry of this.chart[column]) {
      str += entry + `\n`;
    }
    str += "--------------------------\n";
    return str;
  }
}

type InsertArgs = { entry: State; setNumber: number };
type allFromArgs = { setNumber: number; asArray: boolean };
type entryCountArgs = { setNumber: number };

function chart(columnCount: number) {
  return new Chart(columnCount);
}

function rule(name: string) {
  return {
    is(...definition: (string | P<string>)[]) {
      return new Rule(name, definition);
    },
  };
}

class GrammarObj {
  rules: Rule[];
  nonterminals: Set<string>;
  constructor(rules: Rule[]) {
    this.rules = rules;
    this.nonterminals = new Set();
    rules.forEach((r) => this.nonterminals.add(r.symbol));
  }
  isNonTerminal(symbol: string) {
    return this.nonterminals.has(symbol);
  }
  isTerminal(symbol: string) {
    return !this.isNonTerminal(symbol);
  }
  getRule(index: number) {
    const rule = this.rules[index];
    if (rule === undefined) throw new Error("[getRule]: out of bounds index");
    return rule;
  }
  getRHS(index: number) {
    const rule = this.rules[index];
    if (rule === undefined) throw new Error("[getRHS]: out of bounds index");
    return rule.expansion;
  }
  get allRightHands() {
    return this.rules.map((r) => r.expansion);
  }
  get print() {
    let str = "";
    this.rules.forEach((r) => str += r.symbol + `\n`);
    return str;
  }
}

function Grammar(...rules: Rule[]) {
  return new GrammarObj(rules);
}

const grammar = Grammar(
  rule("P").is("S"),
  rule("S").is("S", lit("+"), "M"),
  rule("S").is("M"),
  rule("M").is("M", lit("*"), "T"),
  rule("M").is("T"),
  rule("T").is(num("integer")),
);

type ArgsState = {
  rule: Rule;
  dot: number;
  setIndex: number;
};
const DOT = "●";
class State {
  public ruleDef: Rule;
  public dot: number;
  private columnIdx: number;
  private print: string;
  constructor({ rule, dot, setIndex }: ArgsState) {
    this.ruleDef = rule;
    this.dot = dot;
    this.columnIdx = setIndex;
    this.print = this.updatePrint(rule.symbol, rule.expansion);
    if (this.dot >= 0) {
      this.setDot(dot);
    }
  }
  private updatePrint(symbol: string, expansion: (string | P<string>)[]) {
    let print = [symbol, "=>"];
    for (let i = 0; i < expansion.length; i++) {
      let sym = expansion[i];
      if (sym instanceof P) {
        print.push(sym.type);
      } else print.push(sym);
    }
    return print.join("");
  }
  onRightHas(s: string) {
    for (let i = 0; i < this.print.length; i++) {
      const current = this.print[i];
      const next = this.print[i + 1];
      if (current === DOT) {
        return next === undefined && next===s ? "" : this;
      }
    }
  }

  setDot(index: number) {
    const str = [
      ...this.ruleDef.expansion.slice(0, index),
      DOT,
      ...this.ruleDef.expansion.slice(index),
    ];
    this.print = this.updatePrint(this.ruleDef.symbol, str);
    this.dot = index;
    return this;
  }
  get rule() {
    return this.print;
  }
  get isNotAtEnd() {
    return !this.isComplete;
  }
  get isComplete() {
    const rhsLength = this.ruleDef.expansion.length;
    return this.dot >= rhsLength;
  }
  /** Sets the current state set index.. */
  set columnIndex(index: number) {
    this.columnIdx = index;
  }
  /** Returns the current state set index. */
  get columnIndex() {
    return this.columnIdx;
  }
}

function Parser(grammar: GrammarObj) {
  function parse(source: string) {
    const tokenCount = source.length;
    const rules = grammar.rules;
    const s = chart(tokenCount);
    const parseState = new State({
      rule: rules[0],
      dot: 0,
      setIndex: 0,
    });
    s.insert({ entry: parseState, setNumber: parseState.columnIndex });
    for (let k = 0; k < tokenCount; k++) {
      for (let state of s.chart[k]) {
        if (state.isNotAtEnd) {
          if (isTerminal(nextElement(state))) {
            scan(nextElement(state) as P<string>, k, source[k], s);
          } else predict(nextElement(state), k, s);
        } else complete(nextElement(state), k, s);
      }
    }
    function nextElement(state: State) {
      return state.ruleDef.expansion[state.dot];
    }
    function complete(s: string | P<string>, k: number, chart: Chart) {
      const lastAddedState = chart.lastAddedState;
      if (lastAddedState !== null) {
        const lastAddedStateMatchColumn = lastAddedState.columnIndex;
        const lastAddedStateRuleName = lastAddedState.ruleDef.symbol;
        for (const state of chart.sets[lastAddedStateMatchColumn]) {
          show(state.onRightHas(lastAddedStateRuleName))
        }
      }
    }
    function predict(s: strp, k: number, chart: Chart) {
      for (const rule of grammar.rules) {
        if (rule.symbol === s) {
          chart.insert({
            entry: new State({ rule, dot: 0, setIndex: 0 }),
            setNumber: k,
          });
        }
      }
    }
    function scan(s: P<string>, k: number, term: string, chart: Chart) {
      const parsing = s.run(term);
      if (!parsing.err) {
        const lastAddedState = chart.lastAddedState;
        if (lastAddedState !== null) {
          chart.insert({
            entry: new State({
              rule: lastAddedState.ruleDef,
              dot: 1,
              setIndex: k,
            }),
            setNumber: k + 1,
          });
        }
      }
    }
    function isTerminal(s: string | P<string>): s is P<string> {
      return s instanceof P;
    }

    return { grammar, source, s };
  }

  return { parse };
}

const parsing = Parser(grammar).parse("2+3*4");

show(parsing);
type strp = string | P<string>;




  function parend(state: State, n: astnode) {
    const leftParen = ch("(");
    const rightParen = ch(")");
    const leftBracket = ch("[");
    const rightBracket = ch("]");
    const comma = ch(",");
    let params = [];
    while (check(state, [leftParen, leftBracket])) {
      if (check(state, [leftParen])) {
        if (node.is.varnode(n)) {
          eat(state, leftParen);
          if (!check(state, [rightParen])) {
            params.push(expression(state));
            while (check(state, [comma])) {
              eat(state, comma);
              params.push(expression(state));
            }
          }
          const ateRParen = eat(state, rightParen);
          if (!ateRParen) panic(state, "expected right paren");
          n = node.call(n, params);
        } else return n;
      } else if (check(state, [leftBracket])) {
        eat(state, leftBracket);
        if (!check(state, [rightBracket])) {
          params.push(expression(state));
          while (check(state, [comma])) {
            eat(state, comma);
            params.push(expression(state));
          }
        }
        const ateRBracket = eat(state, rightBracket);
        if (!ateRBracket) panic(state, "expected right bracket");
        n = node.arrnode(params);
      } else return n;
    }
    return n;
  }
  


import {
  ch,
  chain,
  choice,
  dquotedString,
  latin,
  lit,
  many,
  num,
  P,
  R,
  term,
} from "./combinators";

namespace math {
  /** Token specification object. */
  const ast = {
    lit: {
      hexadecimal: term(num("hex")),
      binary: term(num("binary")),
      octal: term(num("octal")),
      scientific: term(num("scientific")),
      float: term(num("float")),
      integer: term(num("integer")),
      rational: term(num("rational")),
      string: term(dquotedString),
      bool: term(choice([ch("true"), ch("false")])),
    },
    delimiter: {
      ["("]: ch("("),
      [")"]: ch(")"),
      [","]: ch(","),
      ["["]: ch("["),
      ["]"]: ch("]"),
    },
    symbol: {
      variable: chain([many([latin("any")])]).map((d) => d.flat().join("")),
    },
    operator: {
      binary: {
        ["|"]: ch("|"),
        ["&"]: ch("&"),
        ["!="]: ch("!="),
        ["=="]: ch("!="),
        ["="]: ch("="),
        [">="]: ch(">="),
        ["<="]: ch("<="),
        ["<"]: ch("<"),
        [">"]: ch(">"),
        [">>"]: ch(">>"),
        ["<<"]: ch("<<"),
        [">>>"]: ch(">>>"),
        ["to"]: ch("to"),
        ["+"]: ch("+"),
        ["-"]: ch("-"),
        ["/"]: ch("/"),
        ["*"]: ch("*"),
        ["%"]: ch("%"),
        ["rem"]: ch("rem"),
        ["mod"]: ch("mod"),
        ["++"]: ch("++"),
        ["--"]: ch("--"),
        ["^"]: ch("^"),
      },
      unary: {
        ["not"]: lit("not"),
        ["~"]: lit("~"),
      },
    },
  };
  export const sexpression: Settings<any> = {
    binaryExpression: (left, op, right) => [op, [left, right]],
    unaryExpression: (op, right) => [op, right],
    variable: (name) => [name],
    operator: (op) => (op),
    callExpression: (name, params) => [name, params.flat()],
    error: (error) => (error),
    list: (elements) => (elements),
    literal: (value) => (value),
    root: (r) => (r.flat()),
  };
  export const defaults: Settings<any> = {
    binaryExpression: (left, op, right) => ({
      value: { left, op, right, },
      kind: "binary-expression",
    }),
    unaryExpression: (op, right) => ({
      value: { op, right },
      kind: "unary-expression",
    }),
    variable: (name) => ({ value: { name }, kind: "variable" }),
    operator: (op) => ({ value: { op }, kind: "operator" }),
    callExpression: (name, params) => ({
      value: { name, params },
      kind: "call-expression",
    }),
    error: (error) => ({ value: error, kind: "error" }),
    list: (elements) => ({ value: elements, kind: "list" }),
    literal: (value) => ({ value, kind: "literal" }),
    root: (root) => ({ root, kind: "root" }),
  };
  export type State = {
    src: string;
    start: number;
    end: number;
    danglingDelimiter: boolean;
    prevtoken: string;
    remaining: string;
    error: string | null;
  };
  export interface Settings<NODE> {
    binaryExpression: (left: NODE, op: NODE, right: NODE) => NODE;
    unaryExpression: (op: NODE, right: NODE) => NODE;
    variable: (p: string) => NODE;
    operator: (p: string) => NODE;
    callExpression: (name: NODE, params: (NODE)[]) => NODE;
    error: (p: string) => NODE;
    list: (elements: (NODE)[]) => NODE;
    literal: (p: string) => NODE;
    root: (r: NODE) => NODE;
  }
  export function sParse(src: string) {
    return parser(sexpression).parse(src);
  }
  export function parse(src: string) {
    return parser(defaults).parse(src);
  }
  export function parser<NODE>(settings: Settings<NODE> = defaults) {
    const root = settings.root;
    const binex = settings.binaryExpression;
    const binop = settings.operator;
    const callnode = settings.callExpression;
    const err = settings.error;
    const listnode = settings.list;
    const prefixUnary = settings.unaryExpression;
    const unaryop = settings.operator;
    const variable = settings.variable;
    const litnode = settings.literal;

    /** Puts the state in panic mode, immediately halting execution. */
    function panic(state: State, error: string) {
      state.error = error;
      state.start += state.end;
    }

    /** Initializes the parser state. */
    function enstate(src: string): State {
      return ({
        src,
        start: 0,
        end: src.length,
        remaining: src,
        prevtoken: "",
        danglingDelimiter: false,
        error: null,
      });
    }

    /**
     * Checks if the remaining source contains a possible match.
     * The parser combinators will match if they encounter a match.
     * But, we don't always want that because of context. The `check`
     * function allows us to try a conditional parse. What to do
     * in the event of a successful (or unsuccessful) parse is determined
     * by the caller.
     */
    function check<t>(state: State, parsers: P<t>[]) {
      const count = parsers.length;
      for (let i = 0; i < count; i++) {
        const parser = parsers[i];
        const res = parser.run(state.remaining);
        if (!res.err) return res;
      }
      return null;
    }

    /** Updates the current state's indices. */
    function tick(state: State, result: Res) {
      const parsed = Array.isArray(result.res)
        ? result.res.join("")
        : result.res;
      if (state.start > state.src.length) {
        panic(state, "Unexpected overread.");
        return;
      }
      const remainingLength = result.rem.length;
      state.prevtoken = parsed;
      state.start = state.src.length - remainingLength;
      state.remaining = result.rem;
    }

    /**
     * Consumes the token. If it matches, move forward.
     * If it doesn't don't move forward.
     */
    function eat(state: State, parser: P<string>) {
      const res = parser.run(state.remaining);
      if (res.err) return false;
      tick(state, res);
      return true;
    }

    /** Parsing template for unary prefix expressions. */
    const unaryexp = (
      state: State,
      operator: unaryOperator,
      child: (state: State) => NODE,
    ): NODE => {
      let expr = child(state);
      const parser = ast.operator.unary[operator];
      while (check(state, [parser])) {
        let op = parser.run(state.remaining);
        if (!op.err) tick(state, op);
        let right = child(state);
        expr = prefixUnary(unaryop(op.res), right);
      }
      return expr;
    };

    /**
     * Parsing template for binary expressions.
     * Note that this doesn't account for right-associativity.
     * We leave that to the interpreter.
     */
    const binexp = (
      state: State,
      operator: binaryOperator,
      child: (state: State) => NODE,
    ): NODE => {
      let expr = child(state);
      const parser = ast.operator.binary[operator];
      while (check(state, [parser])) {
        let op = parser.run(state.remaining);
        if (!op.err) tick(state, op);
        let right = child(state);
        expr = binex(expr, binop(op.res), right);
      }
      return expr;
    };

    /** Parsing template for literal values. */
    const literal = (
      state: State,
      typename: literal,
      child: (state: State) => NODE,
    ): NODE => {
      const parser = ast.lit[typename];
      const parsing: R<string> | null = check(state, [parser]);
      if (parsing) {
        tick(state, parsing);
        return litnode(parsing.res);
      }
      return child(state);
    };

    /**
     * Returns an error node. This is only reached if
     * the parser hits a character not found in the
     * tokenspec.
     */
    const EOI = (state: State) => {
      panic(state, "Unexpected end of input");
      return err("unexpected end of input");
    };

    /**
     * Parses a bracketed expression.
     * In mathlang, brackets are used exclusively
     * for lists. They are not used for property
     * indexing like JavaScript.
     */
    const bracketExp = (state: State): NODE => {
      if (check(state, [ast.delimiter["["]])) {
        let elements: (NODE)[] = [];
        eat(state, ast.delimiter["["]);
        elements.push(expression(state));
        while (check(state, [ast.delimiter[","]])) {
          eat(state, ast.delimiter[","]);
          elements.push(expression(state));
        }
        const ateLeftBracket = eat(state, ast.delimiter["]"]);
        if (!ateLeftBracket) panic(state, "expected right bracket");
        return listnode(elements);
      }
      return EOI(state);
    };

    /** Parses a function call expression. */
    const callExpr = (state: State, node: NODE): NODE => {
      let args: (NODE)[] = [];
      eat(state, ast.delimiter["("]);
      if (!check(state, [ast.delimiter[")"]])) {
        args.push(expression(state));
        while (check(state, [ast.delimiter[","]])) {
          eat(state, ast.delimiter[","]);
          args.push(expression(state));
        }
        const ateRightParen = eat(state, ast.delimiter[")"]);
        if (!ateRightParen) panic(state, "expected right paren");
        node = callnode(node, args);
      } else eat(state, ast.delimiter[")"]);
      return node;
    };

    /** Parses a parenthesized expression. */
    const parenExp = (state: State): NODE => {
      if (check(state, [ast.delimiter["("]])) {
        eat(state, ast.delimiter["("]);
        let expr = expression(state);
        eat(state, ast.delimiter[")"]);
        return expr;
      }
      return bracketExp(state);
    };
    /**
     * Parses a variable. Note the branching here.
     * We regonize the syntax `f(x)` as a function
     * call. So, if we encounter a variable followed
     * by a left-paren, we parse a call expression.
     * Otherwise, we parse a parenthesized expression.
     */
    const varnode = (state: State): NODE => {
      const parsing = check<string>(state, [ast.symbol.variable]);
      if (parsing) {
        tick(state, parsing);
        let node = variable(parsing.res);
        if (check(state, [ast.delimiter["("]])) {
          node = callExpr(state, node);
        }
        return node;
      }
      return parenExp(state);
    };
    const string = (state: State): NODE => literal(state, "string", varnode);
    const bool = (state: State): NODE => literal(state, "bool", string);
    const integer = (state: State): NODE => literal(state, "integer", bool);
    const float = (state: State): NODE => literal(state, "float", integer);
    const rational = (state: State): NODE => literal(state, "rational", float);
    const scinum = (state: State): NODE =>
      literal(state, "scientific", rational);
    const octalnum = (state: State): NODE => literal(state, "octal", scinum);
    const binarynum = (state: State): NODE =>
      literal(state, "binary", octalnum);
    const hex = (state: State): NODE =>
      literal(state, "hexadecimal", binarynum);
    const power = (state: State): NODE => binexp(state, "^", hex);
    const unaryNot = (state: State): NODE => unaryexp(state, "not", power);
    const mod = (state: State): NODE => binexp(state, "mod", unaryNot);
    const rem = (state: State): NODE => binexp(state, "rem", mod);
    const percent = (state: State): NODE => binexp(state, "%", rem);
    const juxtaprod = (state: State): NODE => {
      let n = percent(state);
      let last = n;
      const [vars, nums, lparen] = [
        ast.symbol.variable,
        num("any"),
        ast.delimiter["("],
      ];
      while (check(state, [vars, nums, lparen])) {
        last = percent(state);
        n = binex(n, binop("*"), last);
      }
      return n;
    };
    const prodexp = (state: State): NODE => binexp(state, "*", juxtaprod);
    const divexp = (state: State): NODE => binexp(state, "/", prodexp);
    const difexp = (state: State): NODE => binexp(state, "-", divexp);
    const sumexp = (state: State): NODE => binexp(state, "+", difexp);
    const convert = (state: State): NODE => binexp(state, "to", sumexp);
    const logShift = (state: State): NODE => binexp(state, ">>>", convert);
    const shiftRight = (state: State): NODE => binexp(state, "<<", logShift);
    const shiftLeft = (state: State): NODE => binexp(state, ">>", shiftRight);
    const gt = (state: State): NODE => binexp(state, ">", shiftLeft);
    const lt = (state: State): NODE => binexp(state, "<", gt);
    const lte = (state: State): NODE => binexp(state, "<=", lt);
    const gte = (state: State): NODE => binexp(state, ">=", lte);
    const equality = (state: State): NODE => binexp(state, "=", gte);
    const doubleEqual = (state: State): NODE => binexp(state, "==", equality);
    const unequal = (state: State): NODE => binexp(state, "!=", doubleEqual);
    const bitwiseand = (state: State): NODE => binexp(state, "&", unequal);
    const bitwiseor = (state: State): NODE => binexp(state, "|", bitwiseand);
    const expression = (state: State): NODE => bitwiseor(state);
    const parse = (src: string): NODE => {
      const state = enstate(src);
      let node;
      while (state.start < state.end && state.remaining) {
        node = root(expression(state));
        if (state.error) return err(state.error);
      }
      return node as NODE;
    };

    return { parse };
  }
}

const parsing = math.sParse("2 + 5 = 7");
console.log(parsing);

const { log } = console;

const match = (text: string, start: number, end: number) => ({
  text,
  start,
  end,
});

type Match = ReturnType<typeof match>;


type pfn = (text: string, i: number) => string;

function cached(fn: pfn) {
  const cache = new LRU(10);
  let cache_text = "";
  return (text: string, i: number) => {
    if (text !== cache_text) {
      cache_text = text;
    }
    if (!cache.has(i)) {
      cache.putItem(i, fn(text, i));
    }
    return cache.getItem(i);
  };
}


const { log } = console;
class LRU {
  cache: Map<number, string>;
  constructor(public capacity: number) {
    this.capacity = capacity;
    this.cache = new Map();
  }
  has(i: number) {
    return this.cache.has(i);
  }
  getItem(key: number) {
    const item = this.cache.get(key);
    if (item) {
      this.cache.delete(key);
      this.cache.set(key, item);
    }
    return item;
  }
  putItem(key: number, value: string) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size === this.capacity) {
      this.cache.delete(this.oldest);
    }
    this.cache.set(key, value);
  }
  get oldest() {
    return this.cache.keys().next().value;
  }
}

class State<t> {
  src: string;
  index: number;
  data: t | null;
  cache: LRU;
  constructor(src: string, index: number, data = null) {
    this.src = src;
    this.index = index;
    this.data = data;
    this.cache = new LRU(10);
  }
}

const state = (text: string, start: number, end: number) => ({
  text,
  start,
  end,
  error: start === end,
});
type pstate = ReturnType<typeof state>;

class P {
	constructor(public p:(text:string, i:number)=>pstate) {
		this.p = p;
	}
	parse(src:string) {
	}
}

const lit = (pattern: string) => {
  return new P((input:string,i:number) => {
		if (input.startsWith(pattern)) {
			return state(input, i, i+input.length);
		}
		return state(input,i,i);
  });
};











import {
  a,
  chain,
  choice,
  dquotedString,
  literal,
  many,
  P,
  R,
  of,
  term,
} from "./combinators";

const binex = (left: astnode, op: Operator, right: astnode): binexnode => {
  return {
    value: { left, op, right },
    kind: `binary-expression`,
  };
};

const litnode = (value: string, kind: literal): litnode => {
  return { value, kind };
};

const err = (value: string): errnode => {
  return { value, kind: "error" };
};

const unarynode = (op: Operator, args: astnode): unarynode => {
  return ({
    value: { op, args },
    kind: `unary-expression`,
  });
};

const listnode = (value: astnode[]): listnode => {
  return { value, kind: "list" };
};

namespace algebra {
  type parser = (state: State) => astnode;
  type Res = R<string | string[]>;
  type State = {
    src: string;
    start: number;
    end: number;
    danglingDelimiter: boolean;
    prevtoken: string;
    remaining: string;
    error: errnode | null;
  };
  /**
   * Token specification object.
   * The keys in this object are strictly
   * defined in types.d.ts.
   * Adding a key that isn't specified in
   * types.d.ts will cause errors.
   */
  const ast: tokenspec = {
    lit: {
      hexadecimal: term(of("hexadecimal-number")),
      binary: term(of("binary-number")),
      octal: term(of("octal-number")),
      scientific: term(of("scientific-number")),
      float: term(of("float")),
      integer: term(of("integer")),
      rational: term(of("rational")),
      string: term(dquotedString),
      bool: term(choice([a("true"), a("false")])),
      symbol: chain([many([of('letters')])]).map((d) => d.flat().join("")),
    },
    delimiter: {
      ["("]: a("("),
      [")"]: a(")"),
      [","]: a(","),
      ["["]: a("["),
      ["]"]: a("]"),
    },
    operator: {
      ["|"]: a("|"),
      ["&"]: a("&"),
      ["!="]: a("!="),
      ["=="]: a("!="),
      ["="]: a("="),
      [">="]: a(">="),
      ["<="]: a("<="),
      ["<"]: a("<"),
      [">"]: a(">"),
      [">>"]: a(">>"),
      ["<<"]: a("<<"),
      [">>>"]: a(">>>"),
      ["to"]: a("to"),
      ["+"]: a("+"),
      ["-"]: a("-"),
      ["/"]: a("/"),
      ["*"]: a("*"),
      ["%"]: a("%"),
      ["rem"]: a("rem"),
      ["mod"]: a("mod"),
      ["++"]: a("++"),
      ["--"]: a("--"),
      ["^"]: a("^"),
      ["not"]: literal("not"),
      ["~"]: literal("~"),
    },
  };

  /* -------------------------------------------------------------------------- */
  /*                                   PARSER                                   */
  /* -------------------------------------------------------------------------- */

  export function parse(src: string) {
    const nil: emptynode = { value: "empty", kind: "empty" };

    function run(src: string) {
      const state = enstate(src);
      let node: rootnode = { value: nil, kind: "root" };
      while (state.start < state.end && state.remaining) {
        node.value = expression(state);
        if (state.error) {
          node.value = state.error;
          return node;
        }
      }
      return node;
    }

    function expression(state: State): astnode {
      return bitwiseor(state);
    }

    function bitwiseor(state: State): astnode {
      return binexp(state, "|", bitwiseand);
    }

    function bitwiseand(state: State): astnode {
      return binexp(state, "&", unequal);
    }

    function unequal(state: State) {
      return binexp(state, "!=", doubleEqual);
    }

    function doubleEqual(state: State): astnode {
      return binexp(state, "==", equality);
    }

    function equality(state: State): astnode {
      return binexp(state, "=", gte);
    }

    function gte(state: State): astnode {
      return binexp(state, ">=", lte);
    }

    function lte(state: State): astnode {
      return binexp(state, "<=", lt);
    }

    function lt(state: State): astnode {
      return binexp(state, "<", gt);
    }

    function gt(state: State): astnode {
      return binexp(state, ">", shiftLeft);
    }

    function shiftLeft(state: State): astnode {
      return binexp(state, ">>", shiftRight);
    }

    function shiftRight(state: State): astnode {
      return binexp(state, "<<", logShift);
    }

    function logShift(state: State): astnode {
      return binexp(state, ">>>", convert);
    }

    /**
     * Parses a conversion expression.
     * E.g., 2kg to lbs
     */
    function convert(state: State): astnode {
      return binexp(state, "to", sumexp);
    }

    function sumexp(state: State): astnode {
      return binexp(state, "+", difexp);
    }

    function difexp(state: State): astnode {
      return binexp(state, "-", divexp);
    }

    function divexp(state: State): astnode {
      return binexp(state, "/", prodexp);
    }

    function prodexp(state: State): astnode {
      return binexp(state, "*", juxtaprod);
    }

    /** Parses 'implicit multiplication.' */
    function juxtaprod(state: State) {
      let n = percent(state);
      let last = n;
      while (check(state, [ast.lit.symbol, of("real-number"), ast.delimiter["("]])) {
        last = percent(state);
        n = binex(n, "*", last);
      }
      return n;
    }

    /** Parses a % b. We treat this expression as the integer quotient. */
    function percent(state: State) {
      return binexp(state, "%", rem);
    }

    /** Parses a rem b. (Follows the mathematical definition of remainder). */
    function rem(state: State) {
      return binexp(state, "rem", mod);
    }

    /** Parses a mod b. (Follows JS's definition of '%'. */
    function mod(state: State) {
      return binexp(state, "mod", unaryNot);
    }

    function unaryNot(state: State): astnode {
      return unaryPrefixExp(state, "not", powex);
    }

    function powex(state: State): astnode {
      return binexp(state, "^", literal_hex);
    }

    // BEGIN LITERAL PARSING

    function literal_hex(state: State): astnode {
      return literal(state, "hexadecimal", binarynum);
    }

    function binarynum(state: State): astnode {
      return literal(state, "binary", octalnum);
    }

    function octalnum(state: State): astnode {
      return literal(state, "octal", scinum);
    }

    function scinum(state: State): astnode {
      return literal(state, "scientific", rational);
    }

    function rational(state: State): astnode {
      return literal(state, "rational", float);
    }

    function float(state: State): astnode {
      return literal(state, "float", integer);
    }

    function integer(state: State): astnode {
      return literal(state, "integer", bool);
    }

    function bool(state: State): astnode {
      return literal(state, "bool", string);
    }

    function string(state: State): astnode {
      return literal(state, "string", varnode);
    }

    // END LITERAL PARSING

    /**
     * Parses a variable. Note the branching here.
     * We regonize the syntax `f(x)` as a function
     * call. So, if we encounter a variable followed
     * by a left-paren, we parse a call expression.
     * Otherwise, we parse a parenthesized expression.
     */
    function varnode(state: State): astnode {
      const parsing = check<string>(state, [ast.lit.symbol]);
      if (parsing) {
        tick(state, parsing);
        let node: astnode = litnode(parsing.res, "symbol");
        if (check(state, [ast.delimiter["("]])) {
          node = callExpr(state, node);
        }
        return node;
      }
      return parenExp(state);
    }

    /** Parses a function call expression. */
    function callExpr(state: State, node: astnode): astnode {
      let args: astnode[] = [];
      eat(state, ast.delimiter["("]);
      if (!check(state, [ast.delimiter[")"]])) {
        args.push(expression(state));
        while (check(state, [ast.delimiter[","]])) {
          eat(state, ast.delimiter[","]);
          args.push(expression(state));
        }
        const ateRightParen = eat(state, ast.delimiter[")"]);
        if (!ateRightParen) panic(state, err("expected right paren"));
        node = unarynode(node, args);
      } else eat(state, ast.delimiter[")"]);
      return node;
    }

    /** Parses a parenthesized expression. */
    function parenExp(state: State): astnode {
      if (check(state, [ast.delimiter["("]])) {
        eat(state, ast.delimiter["("]);
        let expr = expression(state);
        eat(state, ast.delimiter[")"]);
        return expr;
      }
      return bracketExp(state);
    }

    /**
     * Parses a bracketed expression.
     * In mathlang, brackets are used exclusively
     * for lists. They are not used for property
     * indexing like JavaScript.
     */
    function bracketExp(state: State): astnode {
      if (check(state, [ast.delimiter["["]])) {
        let elements: astnode[] = [];
        eat(state, ast.delimiter["["]);
        elements.push(expression(state));
        while (check(state, [ast.delimiter[","]])) {
          eat(state, ast.delimiter[","]);
          elements.push(expression(state));
        }
        const ateLeftBracket = eat(state, ast.delimiter["]"]);
        if (!ateLeftBracket) panic(state, err("expected right bracket"));
        return listnode(elements);
      }
      return EOI(state);
    }

    /**
     * Returns an error node. This is only reached if
     * the parser hits a character not found in the
     * tokenspec.
     */
    function EOI(state: State) {
      const error = err("Unexpected end of input");
      panic(state, error);
      return error;
    }

    /** Puts the state in panic mode, immediately halting execution. */
    function panic(state: State, error: errnode) {
      state.error = error;
      state.start += state.end;
    }

    /** Initializes the parser state. */
    function enstate(src: string): State {
      return ({
        src,
        start: 0,
        end: src.length,
        remaining: src,
        prevtoken: "",
        danglingDelimiter: false,
        error: null,
      });
    }

    /**
     * Checks if the remaining source contains a possible match.
     * The parser combinators will match if they encounter a match.
     * But, we don't always want that because of context. The `check`
     * function allows us to try a conditional parse. What to do
     * in the event of a successful (or unsuccessful) parse is determined
     * by the caller.
     */
    function check<t>(state: State, parsers: P<t>[]) {
      const count = parsers.length;
      for (let i = 0; i < count; i++) {
        const parser = parsers[i];
        const res = parser.run(state.remaining);
        if (!res.err) return res;
      }
      return null;
    }

    /** Updates the current state's indices. */
    function tick(state: State, result: Res) {
      const parsed = Array.isArray(result.res)
        ? result.res.join("")
        : result.res;
      if (state.start > state.src.length) {
        panic(state, err("Unexpected overread."));
        return;
      }
      const remainingLength = result.rem.length;
      state.prevtoken = parsed;
      state.start = state.src.length - remainingLength;
      state.remaining = result.rem;
    }

    /**
     * Consumes the token. If it matches, move forward.
     * If it doesn't don't move forward.
     */
    function eat(state: State, parser: P<string>) {
      const res = parser.run(state.remaining);
      if (res.err) return false;
      tick(state, res);
      return true;
    }

    /** Parsing template for unary prefix expressions. */
    function unaryPrefixExp(
      state: State,
      operator: Operator,
      child: parser,
    ): astnode {
      let expr = child(state);
      const parser = ast.operator[operator];
      while (check(state, [parser])) {
        let op = parser.run(state.remaining);
        if (!op.err) tick(state, op);
        let right = child(state);
        expr = unarynode(op.res, right);
      }
      return expr;
    }

    /**
     * Parsing template for binary expressions.
     * Note that this doesn't account for right-associativity.
     * We leave that to the interpreter.
     */
    function binexp(
      state: State,
      operator: Operator,
      child: parser,
    ): astnode {
      let expr = child(state);
      const parser = ast.operator[operator];
      while (check(state, [parser])) {
        let op = parser.run(state.remaining);
        if (!op.err) tick(state, op);
        let right = child(state);
        expr = binex(expr, op.res, right);
      }
      return expr;
    }

    /** Parsing template for literal values. */
    function literal(state: State, typename: literal, child: parser): astnode {
      const parser = ast.lit[typename];
      const parsing: R<string> | null = check(state, [parser]);
      if (parsing) {
        tick(state, parsing);
        return litnode(parsing.res, typename);
      }
      return child(state);
    }

    return run(src);
  }
  export function walk(src: string, fn: (n: astnode) => void) {
    const tree = parse(src);
  }
}

/* ------------------- Live Testing - Remove in Production ------------------ */

import treeify from "treeify";

function log(objx: any) {
  console.log(objx);
}

const view = (x: any) => log(treeify.asTree(x, true, false));
const { parse, walk } = algebra;

const p = walk("x^y + 3", (n) => console.log(n));
// log(p)
export {}



type Operator =
  | "+"
  | "-"
  | "*"
  | "/"
  | "%"
  | "rem"
  | "mod"
  | "to"
  | "|"
  | "&"
  | ">>"
  | "<<"
  | ">>>"
  | "=="
  | "="
  | "!="
  | ">"
  | ">="
  | "<"
  | "<="
  | "++"
  | "--"
  | "^"
  | "not"
  | "~";

interface emptynode {
  value: "empty";
  kind: "empty";
}

type literal =
  | "hexadecimal"
  | "binary"
  | "octal"
  | "scientific"
  | "float"
  | "integer"
  | "rational"
  | "string"
  | "symbol"
  | "bool";

interface litnode {
  value: string;
  kind: literal;
}

interface listnode {
  value: astnode[];
  kind: "list";
}

interface errnode {
  value: string;
  kind: "error";
}

interface unarynode {
  value: { op: Operator; args: astnode };
  kind: `unary-expression`;
}

interface rootnode {
  value: emptynode | astnode;
  kind: "root";
}

interface binexnode {
  value: { left: astnode; op: Operator; right: astnode };
  kind: `binary-expression`;
}

type astnode =
  | rootnode
  | litnode
  | listnode
  | emptynode
  | binexnode
  | unarynode
  | callnode
  | errnode;

type Delimiter = "(" | ")" | "," | "[" | "]";

type tokenspec = {
  operator: { [key in Operator]: P<string> };
  delimiter: {
    [key in Delimiter]: P<string>;
  };
  lit: { [key in literal]: P<string> };
};

const real = of("real-number");
const variable = of("letters");
const equal = a("=");
const plus = a("+");
const r1 = chain([real, variable, equal, real]).map((d: string[]) => {
  let lhs_num = d[0];
  let lhs_var = d[1];
  let rhs_num = d[3];
  return `${lhs_var} = ${rhs_num}/${lhs_num}`;
});
